/*******************************************************************************************
 * SIMPL+ Module Information
 ******************************************************************************************/
/*
 * Programmer: Kaleidescape
 * 
 *  	(c) 2004-2009 Kaleidescape Inc. This Source Code is the intellectual 
 * property of Kaleidescape, Inc. Kaleidescape grants authorized Dealers 
 * and Partners the non-exclusive right to modify and/or compile and/or 
 * compress the Source Code, and upload such modified and/or compiled 
 * and/or compressed Source Code to control systems that control at least 
 * one licensed Kaleidescape System. No right is granted to otherwise 
 * copy, reproduce, modify, upload, download, transmit, or distribute the 
 * Source Code, or derivative works, in any way. The Source Code, and 
 * derivative works, are protected by copyright, trade secret, and other 
 * intellectual property laws and by international treaties, which 
 * provide rights and obligations in addition to the rights and 
 * obligations set forth here.
 * 
 */

/*******************************************************************************************
 * Compiler Directives
 ******************************************************************************************/
#HINT "This processor is for use within the Kaleidescape OSD Module." 
#CATEGORY "4" // Device Interface 
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#DEFINE_CONSTANT LIBRARY_VERSION "2.0" //Kaleidescape library version.

//Useful characters that we'll use in the parsing code
#DEFINE_CONSTANT CR 0x0D		 	// Carriage return
#DEFINE_CONSTANT LF 0x0A		 	// Linefeed
#DEFINE_CONSTANT TAB 0x09		 	// Tab
#DEFINE_CONSTANT BACKSLASH '/'   	// /
#DEFINE_CONSTANT ESCSLASH  '\\'	 	// \
#DEFINE_CONSTANT DOUBLE_QUOTE "\""	// "

#DEFINE_CONSTANT MAX_INT 65535

#DEFINE_CONSTANT MAX_MESSAGE_LENGTH	2048	//Used to initialize various arrays
#DEFINE_CONSTANT INPUT_BUFFER_LENGTH 8192	//8K
#DEFINE_CONSTANT MAX_RESPONSE_ARGS  15		//Number or arguments to account for in the player 
											//response
#DEFINE_CONSTANT MAX_RESPONSE_ARG_LEN 200  	//Maximum length of a single argument

#DEFINE_CONSTANT APPEND_TEXT_1 "\xFE\x01"	//Used to append text displayed on a TP, with a newline
#DEFINE_CONSTANT APPEND_TEXT_2 "\xFE\x02"	//Same as 1, but without a newline
											//Note these only work on TPS panels and later


//Function to return the library version.
STRING_FUNCTION getLibraryVersion()
{
	return(LIBRARY_VERSION);
}

// Function to determine if a given integer is an upper case letter
INTEGER_FUNCTION isUpperLetter(INTEGER character)
{
	return (character >= 'A' && character <= 'Z');
}

// Function to determine if a given integer is an lower case letter
INTEGER_FUNCTION isLowerLetter(INTEGER character)
{
	return (character >= 'a' && character <= 'z');
}

// Function to determine if a given integer is a valid letter
INTEGER_FUNCTION isLetter(INTEGER character)
{
	return (isUpperLetter(character) || isLowerLetter(character));
}

// Function to determine if a given integer is a valid digit
INTEGER_FUNCTION isDigit(INTEGER character)
{
    return (character >= '0' && character <='9');
}

// Function to determine if a given integer is a valid Hex digit
INTEGER_FUNCTION isHex(INTEGER character)	
{
    return(  isDigit(character) || ( character >= 'A' && character <= 'F' )  );
}

// Function to determine if a given integer is a valid sequence number
INTEGER_FUNCTION isSequence(INTEGER character)
{
    return( isDigit(character) || character = '!' || character = '?' );
}

// Function to convert a single char to upper
INTEGER_FUNCTION toUpper(INTEGER character)
{
	if( isLowerLetter(character) ) return(character + 'A' - 'a');
	return(character); //if not a lower case letter, return unchanged
}

// Function to convert a single char to lower
INTEGER_FUNCTION toLower(INTEGER character)	
{
	if( isUpperLetter(character) ) return(character + 'a' - 'A');
	return(character); //if not an upper case letter, return unchanged
}

// General purpose function to remove the right-most characters from a string
STRING_FUNCTION shaveRightCharacter(STRING inputString, INTEGER numToRemove)
{
	if(len(inputString) > numToRemove) return(left(inputString, len(inputString) - numToRemove));
	return("");
}

// Function to convert a string to title caps
STRING_FUNCTION toTitleCaps(STRING inputString)
{
	INTEGER loop;
	INTEGER character;
	INTEGER inWord;
	STRING 	outputString[MAX_MESSAGE_LENGTH];
	
	inWord = OFF;
	
	for(loop = 1 to len(inputString)) //step through every character of inputString
	{
		character = byte(inputString, loop); //extract it
		if(isLetter(character)) //check if it's a letter
		{
			if(inWord) //if we're already in a word
			{
				//set the letter to lower case
				outputString = outputString + chr(toLower(character));
			}
			else //if we're not (beginning of the word)
			{
				//set the letter to upper case (beginning of word)
				outputString=outputString+chr(toUpper(character));
			}
			inWord = ON;
		}
		else //if it's not a letter
		{
			outputString = outputString + chr(character); //just copy verbatum
			inWord = OFF; //note that we're no longer in a word
		}
	}
	return(outputString);
}

// Much less expensive way to append a char with title caps
STRING_FUNCTION appendTitleCaps(STRING inputString, STRING appendString)
{
	INTEGER stringLength;
	STRING 	outputString[MAX_MESSAGE_LENGTH];

	stringLength = len(inputString);
	
	//if there is a previous char and the previous char is a letter...
	if( stringLength > 0 &&	isLetter(byte(inputString, stringLength)) )
	{
		outputString = inputString + lower(appendString); //make new char lower case			
	}
	else //if no previous char, or previous is not a char
	{
		outputString = inputString + upper(appendString); //make new char upper case
	}
		
	return(outputString);
}

// function to properly escape an arbritrary string
STRING_FUNCTION escape(STRING inputString)
{						
	INTEGER loop;
	INTEGER character;
	STRING 	outputString[MAX_MESSAGE_LENGTH];
	
	for(loop = 1 to len(inputString)) //step through every character of inputString
	{
		character = byte(inputString, loop); //extract it
		cSwitch(character) //examine it
		{
			case (':')		: 
			case (BACKSLASH): 
			//escape all of the above
			case (ESCSLASH)	: outputString = outputString + chr(ESCSLASH);  
			default			: outputString = outputString + chr(character); //append the character
		}
	}
	return(outputString);
}

//function to substitute any char for any other
STRING_FUNCTION substitute(STRING inputString, INTEGER characterToReplace, 
							  STRING replacementString)
{
	INTEGER loop;
	INTEGER character;
	INTEGER inputLength;
	INTEGER replacementLength;
	INTEGER outputPosition;
	STRING 	outputString[MAX_MESSAGE_LENGTH];
	
	outputString = "";
	inputLength = len(inputString);
	replacementLength = len(replacementString);
	outputPosition = 1;
	for(loop = 1 to inputLength) //step through every character of inputString
	{
		character = byte(inputString, loop); //extract it
		switch(character) //examine it
		{
			case (characterToReplace):
			{
				setString(replacementString, outputPosition, outputString);
				outputPosition = outputPosition + replacementLength;
			}
			default:
			{
				setString(chr(character), outputPosition, outputString);//append the character
				outputPosition = outputPosition + 1;
			}
		}
	}
	return(outputString);	
}

// function to provide a space if the given string is null (for proper TP display)
STRING_FUNCTION nullToSpace(STRING inputString)
{
	if(inputString != "") return (inputString); //if the string isn't null, just return it.
	return(" "); //otherwise, return a space
}

//This function is used to handle operations that require NAT.
STRING_FUNCTION processNAT(STRING givenURL, STRING hostIP)
{
	STRING URI[500];
	STRING host[50];
	STRING junk[10];

	URI = givenURL;

	junk = remove("//", URI, 1); //remove the http://
    host = remove("/", URI, 1); //pull out the host name   
    
    URI = "http://" + hostIP + "/" + URI;
    
    return(URI);
}

// This function turns an integer into a string with a properly pluraized label.  int=0 returns null.
// assumes that the label can be pluralized by adding an "s" - will work well enough for our labels.
STRING_FUNCTION itoLabel(INTEGER int, STRING label)
{
	STRING result[20];
	switch(int)
	{
		case (0):	//none
		{
			result = "";
		}
		case (1):	//singular
		{
			makeString(result, "%d %s", int, label);
		}
		default:	//plural
		{
			makeString(result, "%d %ss", int, label);
		}
	}
	return(result);
}

// This function creates a proper English text snippet for display
STRING_FUNCTION makeTimeString(INTEGER hours, INTEGER minutes)
{
	STRING result[42];
	STRING hourStr[20];
	STRING minuteStr[20];
	
	hourStr = itoLabel(hours, "hour");
	minuteStr = itoLabel(minutes, "minute");
    
    if( hours > 0 && minutes > 0 )	//if both hours and minutes 
    {
    	result = hourStr + " " + minuteStr;
    }
    else
    {
    	result = hourStr + minuteStr;		// return either hours or minutes or nothing
    }
    
    return(result);
}

/*
 * This function verifies that the incoming message is for the specified device.
 * Returns 0 if invalid message, 1 otherwise
 */
INTEGER_FUNCTION isTargetMessage(INTEGER messageDeviceId, INTEGER messageZoneId, INTEGER messageSequence,
								INTEGER targetDeviceId, INTEGER targetZoneId, INTEGER targetSequence,
								INTEGER directConnect, INTEGER debug)
{		         
    // Check that this response is from the device we want to talk to.
   	if(messageDeviceId != targetDeviceId)
   	{
   		if(directConnect = OFF || (directConnect = ON && messageDeviceId != 1))
   		{
	    	if(debug) print("Ignoring Address: %d   (My Address is %d.)\n", messageDeviceId, targetDeviceId);
    		return(0); //indicate that the message is not OK (not addressed to us)
    	}
    }	
      
    if(messageZoneId != targetZoneId && messageZoneId > 0)
    {
    	if(debug) print("Ignoring Zone ID: %d   (My Zone ID is %d)\n", messageZoneId, targetZoneId);
		return(0);
    }    
   		   		    
    if(messageSequence != '!' && messageSequence != '?') //if the message sequence is a digit
    {
    	if(messageSequence - '0' != targetSequence) //if the sequence doesn't match
    	{
    		if(debug)
    		{
    			print("Bad Sequence: %c  Looking for: %d\n", messageSequence, targetSequence);
    		}
    		return(0);
    	}
    }
	
	return(1);
}

/*
 * Validate that the message is valid
 * used by the parseMessage function
 * Returns 0 if invalid message, 1 otherwise
 *
 * If we're using the OSD, the deviceZoneId should be 0.
 */
INTEGER_FUNCTION validateMessage(STRING message, BYREF INTEGER messageDeviceId, BYREF INTEGER messageZoneId, 
								BYREF INTEGER messageSequence, INTEGER messageEnd, INTEGER playerID, 
								INTEGER debug)
{
	INTEGER calculatedChecksum;
	INTEGER responseChecksum;
	INTEGER index;
	INTEGER segmentDelimiter;
	
	/*
     * The shortest response is "01/1/000:" (binary delimited), so if we have something
     * shorter than that, then we can just ignore it since we know it's
     * corrupted.
     */
    if (messageEnd < 9)
    {
    	if(debug) print ("Response too short: %s\n",message);
        return(0);
    }
    
    /*
     * If using serial number device ID messages, the message will be longer
     * #00000000FFFF/1/000:/xx
     */
    if (byte(message, 1) = '#' && messageEnd < 22) //shortest len for a sn device ID type message
    {
    	if(debug) print ("Response too short: %s\n", message);
        return(0);    	
    }
    
    /*
     * Determine the message format - binary or printable
     * The byte \x02 delimits fields in binary mode, and checksums aren't used
     */
    if (byte(message, messageEnd) = 2)
    {
    	segmentDelimiter = 1;
    }
    else	//if not in binary mode, then it's a printable message
    {
    	segmentDelimiter = BACKSLASH;
    }
    

	//If using serial number with a zone, Message format should be: #00000000FFFF.01/1/
    if (byte(message, 1) = '#' && byte(message, 14) = '.') //device ID with zone
    {
    	if(!isHex(byte(message, 2)) 					||
    	   !isHex(byte(message, 3)) 					||
    	   !isHex(byte(message, 4)) 					||
    	   !isHex(byte(message, 5)) 					||
    	   !isHex(byte(message, 6)) 					||
    	   !isHex(byte(message, 7)) 					||
    	   !isHex(byte(message, 8)) 					||
    	   !isHex(byte(message, 9)) 					||
    	   !isHex(byte(message, 10)) 					||
    	   !isHex(byte(message, 11)) 					||
    	   !isHex(byte(message, 12)) 					||
    	   !isHex(byte(message, 13)) 					||
    	   !isDigit(byte(message, 15)) 					||
    	   !isDigit(byte(message, 16)) 					||
    	   byte(message, 17) != segmentDelimiter		||
    	   !isSequence(byte(message, 18)) 				||
    	   byte(message, 19) != segmentDelimiter		)
        {           
    		print("Kaleidescape Player ID %d:  Received garbled message.\n    message is: %s\n",
    			playerID, message);
        	return(0);
        }
        
        messageDeviceId = 0;
        messageZoneId = atoi(mid(message, 15, 2));
        
        print("Serial Number device IDs are not supported.  Bad Address: %s\n", left(message,13));
        return(0);
    }
    //If using serial number without a zone, message format should be: #00000000FFFF/1/
    else if (byte(message,1) = '#')
    {
    	if(!isHex(byte(message, 2)) 					||
    	   !isHex(byte(message, 3)) 					||
    	   !isHex(byte(message, 4)) 					||
    	   !isHex(byte(message, 5)) 					||
    	   !isHex(byte(message, 6)) 					||
    	   !isHex(byte(message, 7)) 					||
    	   !isHex(byte(message, 8)) 					||
    	   !isHex(byte(message, 9)) 					||
    	   !isHex(byte(message, 10)) 					||
    	   !isHex(byte(message, 11)) 					||
    	   !isHex(byte(message, 12)) 					||
    	   !isHex(byte(message, 13)) 					||
    	   byte(message, 14) != segmentDelimiter 		||
    	   !isSequence(byte(message, 15)) 				||
    	   byte(message, 16) != segmentDelimiter		)
        {          
    		print("Kaleidescape Player ID %d:  Received garbled message.\n    message is: %s\n",
    			playerID, message);
        	return(0);
        }
        
        messageDeviceId = 0;
        messageZoneId = 0;
        
	    print("Serial Number device IDs are not supported.  Bad Address: %s\n", left(message,13));
    	return(0);
    }
    //If using a zone ID, message format should be 01.01/1/
	else if (byte(message,3) = '.') //contains a zone ID
	{
    	if(!isDigit(byte(message, 1)) 					||
    	   !isDigit(byte(message, 2)) 					||
    	   !isDigit(byte(message, 4)) 					||
    	   !isDigit(byte(message, 5)) 					||
    	   byte(message, 6) != segmentDelimiter 		||
    	   !isSequence(byte(message, 7)) 				||
    	   byte(message, 8) != segmentDelimiter 		)
        {           
    		print("Kaleidescape Player ID %d:  Received garbled message.\n    message is: %s\n", 
    				playerID, message);
        	return(0);     
        }    	

	    messageDeviceId = atoi(left(message, 2));
   		messageZoneId  = atoi(mid(message, 4, 2));
   		messageSequence = byte(message,7);
   	}
	//If using a CPDID only, message format should be 01/1/
	else
	{
		if(!isDigit(byte(message, 1)) 					||
    	   !isDigit(byte(message, 2)) 					||
    	   byte(message, 3) != segmentDelimiter			||
    	   !isSequence(byte(message, 4)) 				||
    	   byte(message, 5) != segmentDelimiter			)
		{           
    		print("Kaleidescape Player ID %d:  Received garbled message.\n    message is: %s\n",
    			playerID, message);
        	return(0);        	
        }
	    messageDeviceId = atoi(left(message, 2));
	    messageSequence = byte(message, 4);
	    messageZoneId  = 0;
    }
    
    if(segmentDelimiter = BACKSLASH)	   // if using printable delimiters, calculate the checksum and verify it.
    {
	    calculatedChecksum = 0;
	    for(index = 1 to (messageEnd - 2) ) // skip last two characters, that's the checksum itself.
	    {
	        calculatedChecksum = (calculatedChecksum + byte(message, index)) mod 100;
	    }
	    
	    responseChecksum = atoi(right(message, len(message) - messageEnd + 2));
	    if (calculatedChecksum != responseChecksum)
	    {
	    	if(debug) print("Bad checksum: %d vs %d\n", calculatedChecksum, responseChecksum);
	        return(0);
	    }
	}
    return(1);   
}

//Provided for backwards compatibility.
INTEGER_FUNCTION isValidMessage(STRING message, INTEGER deviceId, INTEGER deviceZoneId, 
								INTEGER sequenceSent, INTEGER messageEnd, INTEGER playerID, 
								INTEGER directConnect, INTEGER debug)
{
	INTEGER messageDeviceId;
	INTEGER messageZoneId;
	INTEGER messageSequence;
	
	if(validateMessage(message, messageDeviceId, messageZoneId, messageSequence, 
					   messageEnd, playerID, debug))
	{
		return (isTargetMessage(messageDeviceId, messageZoneId, messageSequence,
								deviceId, deviceZoneId, sequenceSent,
								directConnect, debug));
	}
	else
	{
		return(0);
	}
}								

//Parses the arguments used by parseMessage() and parseInit2Message() in printable delimiter format
FUNCTION getNArgumentsPrintable(STRING arguments[], BYREF INTEGER numArgs, 
					   INTEGER newTotalArgs, STRING message, 
					   BYREF INTEGER messagePosition, BYREF INTEGER messageEnd)
{
	INTEGER	character;
	INTEGER escaped;
	INTEGER argumentLength;
		             
	//Initialize our variables
	escaped = 0;
	argumentLength = 0;
	
	while (messagePosition <= messageEnd && numArgs < newTotalArgs)
	{        	
        //get the character being examined 
        character = byte(message, messagePosition);
        messagePosition = messagePosition + 1;
        
        if (escaped = 1)
        {
        	// The previous character was a backslash, treat this character specially.
            switch (character)
            {
                case ('d'):
                {
                    // The following three digits make up the character.                    
                    character = (byte(message, messagePosition) - '0') * 100;
                    character = character + (byte(message, messagePosition + 1) - '0') * 10;
                    character = character + (byte(message, messagePosition + 2) - '0');
                    messagePosition = messagePosition + 3;
                }
                case ('t'):
                {
                    character = TAB;
                }
                case ('n'):
                {
                    character = LF;
                }
                case ('r'):
                {
                    character = CR;
                }
                default:
                {
                    // All other characters are simply themselves, nothing to do here.
                }
            }
            if(argumentLength = 0) arguments[numArgs] = ""; //Clear the argument.
            
            // Append character to the response                        
            if(argumentLength < MAX_RESPONSE_ARG_LEN)
            {
            	setString(chr(character), argumentLength + 1, arguments[numArgs]);            	
            	argumentLength = argumentLength + 1;
            }

            // The escape only applies to the next character.  After that we're back to normal.
            escaped = 0;
        }
        else  // here if escaped is 0
        {
            switch (character)
            {
            	case (ESCSLASH): // Treat the next character specially.
            	{                    
                    escaped = 1;
                }
                case (':'): // Colons separate arguments, so prep the next argument
                {
                	numArgs = numArgs + 1;
                	argumentLength = 0;
                }
                default:
                {
                	if(argumentLength = 0) arguments[numArgs] = ""; //Clear the argument.
                	
                    // Normal character, append it.
    		        if(argumentLength < MAX_RESPONSE_ARG_LEN)
    		        {
    		        	setString(chr(character), argumentLength + 1, arguments[numArgs]);
    		        	argumentLength = argumentLength + 1;
    		        }
                }
            }
        }
    }
}


//Parses the arguments used by parseMessage() and parseInit2Message() in binary delimiter format
FUNCTION getNArgumentsBinary(STRING arguments[], BYREF INTEGER numArgs, 
					   INTEGER newTotalArgs, STRING message, 
					   BYREF INTEGER messagePosition, BYREF INTEGER messageEnd)
{
	INTEGER	delimiterPosition;
	
	while (messagePosition <= messageEnd && numArgs < newTotalArgs)
	{
		delimiterPosition = find("\x02", message, messagePosition);
		
		//if no delimiter is found, move the position to the end and quit the loop
		if(delimiterPosition = 0)
		{
			messagePosition = messageEnd + 1;	
			break;
		}
		
		arguments[numArgs] = mid(message, messagePosition, (delimiterPosition - messagePosition) );
		numArgs = numArgs + 1;
		messagePosition = delimiterPosition + 1;
		}
}

//Parses the arguments used by parseMessage() and parseInit2Message()
FUNCTION getNArguments(STRING arguments[], BYREF INTEGER numArgs, 
					   INTEGER newTotalArgs, STRING message, 
					   BYREF INTEGER messagePosition, BYREF INTEGER messageEnd)
{
	if(byte(message,messageEnd) = 2)	//if the message is terminated with a binary delimiter
	{
		getNArgumentsBinary(arguments, numArgs, newTotalArgs, message, messagePosition, messageEnd);
	}
	else		//otherwise, assume it's in the printable delimiter format
	{
		getNArgumentsPrintable(arguments, numArgs, newTotalArgs, message, messagePosition, messageEnd);
	}
}

// Decode and display the error code & message
FUNCTION printPlayerError(INTEGER errorCode, STRING details, INTEGER playerId)
{
	string description[30];
	
	switch(errorCode)  {
		case(1):
		{
			description =  "Message too long.";
		}
		case(2):
		{
			description =  "Message contains invalid character.";
		}
		case(3):
		{
			description =  "Checksum error.";
		}
		case(4):
		{
			description =  "Invalid device or device is offline.";
		}
		case(5):
		{
			description =  "Device unavailable.";
		}
		case(10):
		{
			description =  "Invalid request.";
		}
		case(11):
		{
			description =  "Invalid number of parameters.";
		}
		case(12):
		{
			description =  "Invalid parameter.";
		}
		case(13):
		{
			description =  "Device identifier conflict.";
		}
		case(14):
		{
			description =  "Invalid sequence number.";
		}
		case(15):
		{
			description =  "Disallowed due to parental control.";
		}
		case(16):
		{
			description =  "Invalid passcode.";
		}
		case(17):
		{
			description =  "Invalid content handle.";
		}
		case(20):
		{
			description =  "Command not processed.";
		}
		case(999):
		{
			description =  "Undetermined error.";
		}
		default:
		{
			description =  "Unknown error.";
		}
	}
	
	//send error text to console
	print("Kaleidescape Device ID %d: Error %03d, %s  %s\n", 
		playerId, errorCode, description, details);
}      

// Decrypt the device type, and ensure that the device is a valid one that can be controlled
INTEGER_FUNCTION checkDeviceType(INTEGER deviceType, INTEGER playerId)
{
	STRING typeText[30];
	
	switch(deviceType)	{
		case(1):
		{
			typeText = "a Server";
		}
		
		case(2):
		{
			typeText = "a Player";
			return(1); //halt execution of this function with a success result
		}
		
		case(3):
		{
			typeText = "a Bulk Loader";
		}
		
		case(5):
		{
			typeText = "a DVD Reader";
		}
		
		case(7):
		{
			typeText = "";
			return(1); //halt execution of this function with a success result
		}
		
		case(8):
		{
			typeText = "a Music Player";
			return(1); //halt execution of this function with a success result
		}
		
		default:
		{
			typeText = "an unknown device";
		}
	}
	
	//if control falls here, we are not talking to a player.
	
	print("\nKaleidescape Device ID %d is %s, not a Player.\n", playerID, typeText);
	print("The Kaleidescape module only controls a Kaleidescape Player.\n\n");
	return(0); //indicate failure
} 

FUNCTION refactorConnectionSettings(INTEGER statedPlayerID, STRING playerSN, BYREF INTEGER playerID, STRING connectedDeviceSN, INTEGER connectedDeviceID, BYREF INTEGER directConnect, INTEGER debug)
{
	//if the serial number of the controlled player is the same as the connected dev
	if(playerSN = connectedDeviceSN)
	{
		directConnect = ON; //we are directly connected
	}
	else
	{
		directConnect = OFF; //otherwise, we are not
	}

		
	if(statedPlayerID = 1) //if the given player id is 1 (implying a direct connection)
	{
		//then use the ID of the connected device, no matter what it is
		playerId = connectedDeviceID;
		if(playerId = 0) playerId = 1;
		directConnect = ON;
	}
		
	/*
	 * This solves problems where the installer direct connects the player
	 * but the player's ID is actually something other than 01.
	 */
	if(debug)
	{			
		print("K module refactored interface.\n");
		print("          Player SN = %s\n", playerSN);
		print("Connected Device SN = %s\n", connectedDeviceSN);
		print("Direct connect = %d\n\n", directConnect);
		print("Stated ID = %u, Connected ID = %u, Player ID = %u.\n\n",
			statedPlayerID, connectedDeviceID, playerID);
	}
	
}


INTEGER_FUNCTION validateDevice(STRING moduleName, INTEGER CPDID, STRING deviceName, INTEGER numVidZones, INTEGER numAudZones, INTEGER myZone)
{
	STRING errorText[255];
	if(deviceName = "") deviceName = "device";
	
	if(myZone > 0)		//this will be true if myZone is a music zone
	{
		if(myZone <= numAudZones)
			return(1);
			
	    if(numAudZones = 0)
	    {
	    	makeString(errorText, "Kaleidescape Config ERROR! %s is set to control CPDID %02d, zone %02d; a %s with no audio zones.", moduleName, CPDID, myZone, deviceName);
		}
	    else
	    {
	    	makeString(errorText, "Kaleidescape Config ERROR! %s is set to control CPDID %02d, zone %02d; a %s with only %d audio zone(s).", moduleName, CPDID, myZone, deviceName, numAudZones);
	    }
	}
	else
	{
		if(numVidZones > 0)
			return(1);
			
    	makeString(errorText, "Kaleidescape Config ERROR! %s is set to control CPDID %02d; a %s which has no video zones.", moduleName, CPDID, deviceName);			
	}
	
	GenerateUserError("%s", errorText);
	Print("\n\n%s\n\n", errorText);
	
	return(0);
}

/*
 * The following functions manage the connection state
 */
#DEFINE_CONSTANT MAX_CONNECTION_COMMANDS 5
 
//different states
#DEFINE_CONSTANT STATE_PORT_CLOSED		0		//port is closed
#DEFINE_CONSTANT STATE_PORT_OPENED		1		//port is open, no traffic yet (or not traffic)
#DEFINE_CONSTANT STATE_K_CONNECTION		2		//port is returning valid K responses, but not sending traffic to device
#DEFINE_CONSTANT STATE_PASSING_TRAFFIC	3		//port is passing traffic to connected devices, but our device is offline
#DEFINE_CONSTANT STATE_DEVICE_ONLINE	4		//device is online and communicating normally
#DEFINE_CONSTANT STATE_DEVICE_ON		5		//device is on
#DEFINE_CONSTANT STATE_CONFIG_VALID		6		//the configuration is good (proper zones, etc.)
#DEFINE_CONSTANT STATE_UNDEF			999

#DEFINE_CONSTANT POWER_OFF				0
#DEFINE_CONSTANT POWER_ON				1
#DEFINE_CONSTANT POWER_UNKNOWN			254

//various reponses
#DEFINE_CONSTANT RESPONSE_NO_ACTION		0
#DEFINE_CONSTANT RESPONSE_SEND_COMMAND	1
#DEFINE_CONSTANT RESPONSE_DIRECT_SEND	2
#DEFINE_CONSTANT RESPONSE_INITIALIZE	3
#DEFINE_CONSTANT RESPONSE_CLEAR_INIT	4
#DEFINE_CONSTANT RESPONSE_INIT_CONN		5
#DEFINE_CONSTANT RESPONSE_POWERED_OFF	6

//various connection state events
#DEFINE_CONSTANT EVENT_VALID_MESSAGE 	1		//when a valid K message is received
#DEFINE_CONSTANT EVENT_DEVICE_INFO 		2		//when we've received a dev info from the target device
#DEFINE_CONSTANT EVENT_POWER_STATE_ON	3		//received DEVICE_POWER_STATE, and this zone is on
#DEFINE_CONSTANT EVENT_POWER_STATE_OFF	4		//received DEVICE_POWER_STATE, and this zone is off
#DEFINE_CONSTANT EVENT_VALIDATED_CONFIG 5		//the configuration is valid
#DEFINE_CONSTANT EVENT_01_DEVICE_INFO	10		//received dev info from device 01
#DEFINE_CONSTANT EVENT_01_POWER_STATE_OFF 11	//received DEVICE_POWER_STATE, and 01 is on
#DEFINE_CONSTANT EVENT_01_POWER_STATE_ON  12	//received DEVICE_POWER_STATE, and 01 is off
#DEFINE_CONSTANT EVENT_01_BANG_020		13		//received 01/!/020:
#DEFINE_CONSTANT EVENT_DEVICE_ONLINE	14		//called in response to finding our CPDID in AVAILABLE_DEVICES
#DEFINE_CONSTANT EVENT_DEVICE_OFFLINE	15		//called in response to not finding our CPDID in AVAILABLE_DEVICES
#DEFINE_CONSTANT EVENT_PLAYER_RESTART	16		//received PLAYER_RESTART

#DEFINE_CONSTANT EVENT_MODULE_START		100		//startup
#DEFINE_CONSTANT EVENT_PORT_OPEN 		101		//the port is open
#DEFINE_CONSTANT EVENT_PORT_CLOSED 		102		//the port is closed
#DEFINE_CONSTANT EVENT_SEND_TIMEOUT		103		//a send message got no reponse
#DEFINE_CONSTANT EVENT_MIDNIGHT			104		//midnight has passed
#DEFINE_CONSTANT EVENT_10_SECONDS		105		//triggers every 10 seconds
#DEFINE_CONSTANT EVERY_30_SECONDS		106
#DEFINE_CONSTANT EVENT_POWER_ON_PUSH	107		//power on was pressed on the module
#DEFINE_CONSTANT EVENT_POWER_ON_RELEASE 108		//power on was released on the module
#DEFINE_CONSTANT EVENT_POWER_OFF_PUSH	109		//power off was pressed on the module

#DEFINE_CONSTANT EVENT_ERROR_OFFSET		1000

 
INTEGER_FUNCTION connectionHandler(INTEGER stateEvent, BYREF INTEGER state, BYREF STRING commands[], BYREF INTEGER commandCount, BYREF INTEGER powerState, BYREF INTEGER powerStateStatus, BYREF STRING moduleDescription, INTEGER directConnection, INTEGER debug)
{
	INTEGER newState;
	INTEGER oldState;
	oldState = state;
	newState = STATE_UNDEF;
	
 	if(debug) print("connectionHandler called with state event %d.  State=%d, Power state=%d\n", stateEvent, state, powerState);
 	switch(stateEvent)
 	{
 		//connection step 2
 		case (EVENT_VALID_MESSAGE):
 		{
 			//This first event must normally exit fast as it's checked on every incoming message
 			if(state >= STATE_K_CONNECTION) 
 				return(RESPONSE_NO_ACTION);	//if we're already at this state, do nothing
 			
 			newState = STATE_K_CONNECTION;
 			
 			if(debug) print("ConnectionHandler - Connection step 2\n");
 		}

		case (EVENT_10_SECONDS):
		{
			//this is a failsafe event for when a 232 connection is set up without any other indication
			//will also keep track of the power status
			if(state = STATE_PORT_OPENED)
				newState = STATE_PORT_OPENED;
	
			//if the device in online but the power state is unknown, check it			
			if( state <> STATE_UNDEF && state >= STATE_DEVICE_ONLINE && powerState = POWER_UNKNOWN )
			{
	 			makeString(commands[1], "GET_DEVICE_POWER_STATE:");
	 			commandCount = 1;
	 			return(RESPONSE_SEND_COMMAND);
			}
		}
 		
 		//connection step 0 - clear any states
 		case (EVENT_MODULE_START):
 		{
 			newState = STATE_PORT_CLOSED;
 		}
 		
		//connection step 1  - check if the connected device is on.  Might be called twice during startup.		
 		case (EVENT_PORT_OPEN):
 		{
 			if(state < STATE_PORT_OPENED)
	 			newState = STATE_PORT_OPENED;
 		}
 		
 		case (EVENT_PORT_CLOSED):
 		{
 			newState = STATE_PORT_CLOSED;
 		}

 		case (EVENT_PLAYER_RESTART):
 		{
 			newState = STATE_K_CONNECTION;
 		}
 		
 		
 		//connection step 3
 		case (EVENT_01_DEVICE_INFO):
 		{
 			if(state < STATE_PASSING_TRAFFIC)
	 			newState = STATE_PASSING_TRAFFIC;
 		}
        
        //connection step 4
 		case (EVENT_DEVICE_INFO):
 		{
 			if(state < STATE_DEVICE_ONLINE)
	 			newState = STATE_DEVICE_ONLINE;
 		} 		
 		
 		case (EVENT_DEVICE_ONLINE):
 		{
 			if(state < STATE_DEVICE_ONLINE)
	 			newState = STATE_DEVICE_ONLINE;
 		}
 		
 		//connection step 5
 		case (EVENT_POWER_STATE_ON):
 		{
 			if(state < STATE_DEVICE_ON)
				newState = STATE_DEVICE_ON;	//we're online
			else
	 			powerState = POWER_ON;
 		}
 		
 		case (EVENT_POWER_STATE_OFF):
 		{
 			powerState = POWER_OFF;			//we're off 
 			
 			if(state != STATE_DEVICE_ONLINE)			
	 			newState = STATE_DEVICE_ONLINE;	//we're online
 		}
 		
 		//connection step 7
 		case (EVENT_VALIDATED_CONFIG):
 		{
 			if(state < STATE_CONFIG_VALID)
	 			newState = STATE_CONFIG_VALID;
 		}
 		
 		case (EVENT_01_POWER_STATE_OFF):
 		{
 			if(state < STATE_K_CONNECTION)
 			{
 				newState = STATE_K_CONNECTION;
 			}
 			if(directConnection)
 			{
 				powerState = POWER_OFF;			//we're powered off
 			}
 			
 		}
 		
 		case (EVENT_01_POWER_STATE_ON):
 		{
 			if(state < STATE_K_CONNECTION)
 			{
 				newState = STATE_K_CONNECTION;
 			}
 			if(directConnection)
 			{
 				powerState = POWER_ON;			//but powered on
			}
 		}
 		
 		//we should always at least receive error 004 or 020.  If not, something is not good
 		case (EVENT_SEND_TIMEOUT):
 		{
 			if(state > STATE_PORT_OPENED)
				newState = STATE_PORT_OPENED;
 		}
 		
 		//received the "I can't pass traffic" error.  Port is open but not passing traffic
 		case (EVENT_01_BANG_020):
 		{
 			if(directConnection)		//if we're directly connected
 			{
 				if(state != STATE_DEVICE_ONLINE)
	 				newState = STATE_DEVICE_ONLINE;	//we're online
	 				
 				powerState = POWER_OFF;			//but powered off
 			}
 			else						//if we're not directly connected
 			{
 				if(state != STATE_K_CONNECTION)
	 				newState = STATE_K_CONNECTION;
 			}
 		}
 		
 		//our device not found in available devices.  
 		case (EVENT_DEVICE_OFFLINE):
 		{
 			if(!directConnection)		//if we're not directly connected
 			{
 				if(state != STATE_PASSING_TRAFFIC)
	 				newState = STATE_PASSING_TRAFFIC;
 			}
 		}
 		
 		
 		//received the "device offline" error.  Port is open and passing traffic, device offline
 		case (EVENT_ERROR_OFFSET + 004):
 		{
 			if(!directConnection)		//if we're not directly connected
 			{
 				if(state != STATE_PASSING_TRAFFIC)
	 				newState = STATE_PASSING_TRAFFIC;
 			}
 		}
 		
 		//we'll only get this error if we're online but in standby
 		case (EVENT_ERROR_OFFSET + 020):
 		{
 			if(state > STATE_DEVICE_ONLINE)
	 			newState = STATE_DEVICE_ONLINE;
	 			
 			powerState = POWER_OFF;
 		}
 		
 		case (EVERY_30_SECONDS):
 		{
 			makeString(commands[5], "\n");	//send just a CR to make sure the port is still open
 			return(RESPONSE_DIRECT_SEND); 			
 		}
 		
 		case (EVENT_MIDNIGHT):
 		{
 			if(state = STATE_DEVICE_ONLINE)
 			{
	 			makeString(commands[1], "SEND_TO_SYSLOG:INFORMATION:%s:", escape(moduleDescription));
 				commandCount = 1;
 				return(RESPONSE_SEND_COMMAND);
 			}
 			else return(RESPONSE_NO_ACTION);
 		}
 		
 		case (EVENT_POWER_ON_PUSH):
 		{
 			powerStateStatus = ON;
 			
 			//if the power is off, set the state to unknown in anticipation of an ON event
 			if(powerState = POWER_OFF)
 			{
 				powerState = POWER_UNKNOWN;
 				commandCount = 0;
 				return(RESPONSE_SEND_COMMAND);	//return with no commands to evaluate the power state
 			}
 			
 			//edge case for devices that improperly respond to power state changes
 			if(powerState = POWER_UNKNOWN && state >= STATE_DEVICE_ON)
 			{
 				powerState = POWER_ON;
 				commandCount = 0;
 				return(RESPONSE_SEND_COMMAND);	//return with no commands to evaluate the power state
 			}

 		}
 		
 		case (EVENT_POWER_ON_RELEASE):
 		{
 			powerStateStatus = OFF;
 		}
 		
 		case (EVENT_POWER_OFF_PUSH):
 		{	
 			powerStateStatus = OFF;
 			
 			//if the power is on, set the state to unknown in anticipation of an OFF event
 			if(powerState = POWER_ON)
 			{
 				powerState = POWER_UNKNOWN;
 				commandCount = 0;
 				return(RESPONSE_SEND_COMMAND);	//return with no commands to evaluate the power state
 			}
 		}
 		
 		default:
 		{
 			if(debug) print("Kaleidescape connectionHandler unknown event: %d\n", stateEvent);
 		}
 	}
 	
 	if(newState != STATE_UNDEF) 
 	{
 		//if the newState is higher, only go up by one step to not miss anything
 		if(newState > state) newState = state + 1;
 		state = newState;
 	}
 	
 	//take action depending on the new state
 	switch (newState)
 	{
 		case (STATE_PORT_CLOSED):
 		{
 			powerState = POWER_UNKNOWN;
 			return(RESPONSE_CLEAR_INIT);
 		}
 		case (STATE_PORT_OPENED): 
 		{
 			powerState = POWER_UNKNOWN;
 			makeString(commands[5], "01/0/GET_DEVICE_POWER_STATE:\n");
 			return(RESPONSE_DIRECT_SEND);
 		}
 		case (STATE_K_CONNECTION): 
 		{
 			if(!directConnection)
 				powerState = POWER_UNKNOWN;
 				
 			makeString(commands[5], "01/0/GET_DEVICE_INFO:\n"); 			
 			return(RESPONSE_DIRECT_SEND);
 		}
 		case (STATE_PASSING_TRAFFIC): 
 		{
 			if(!directConnection)
 				powerState = POWER_UNKNOWN;
 			
 			makeString(commands[1], "GET_DEVICE_INFO:");
 			commandCount = 1; 			
 			return(RESPONSE_INIT_CONN);
 		}
 		case (STATE_DEVICE_ONLINE): 
 		{
 			if(oldState < newState)	//only reinit the connection if it's a new connection
 			{
	 			makeString(commands[1], "SEND_TO_SYSLOG:INFORMATION:%s:", escape(moduleDescription));
	 			makeString(commands[2], "GET_DEVICE_POWER_STATE:");
	 			commandCount = 2;
	 			return(RESPONSE_SEND_COMMAND);
	 		}
	 		else
	 		{
	 			//indicate that the device has been powered off (was on)
	 			return(RESPONSE_POWERED_OFF);
	 		}
	 	}
 		case (STATE_DEVICE_ON):
 		{
 			powerState = POWER_ON;
			makeString(commands[1], "GET_DEVICE_TYPE_NAME:");
			makeString(commands[2], "GET_NUM_ZONES:");
			commandCount = 2;
			return(RESPONSE_SEND_COMMAND);
 		}
 		case (STATE_CONFIG_VALID): 
 		{
			return(RESPONSE_INITIALIZE);	//init 	
 		}
 	}
 	
 	//check the power state, status and connection state
	if(powerStateStatus && powerState = POWER_OFF)
	{
	    if(state = STATE_DEVICE_ONLINE || ( directConnection && state >= STATE_K_CONNECTION ) )
		{	
			//turn on immediately
			makeString(commands[1], "LEAVE_STANDBY:");
			commandCount = 1;
			
			return(RESPONSE_SEND_COMMAND);
		}
	}
	
	return(RESPONSE_NO_ACTION);
}

// Small parser to get messages addressed to id 01, zone 0 (initialization messages)
INTEGER_FUNCTION parse010MessageEvent(STRING message, INTEGER messageEnd, INTEGER playerID, INTEGER directConnect, BYREF STRING connectedDeviceSN, BYREF INTEGER connectedDeviceID, INTEGER debug)
{
	INTEGER numArgs;	// the number of args
	INTEGER messagePosition;
	STRING  args[MAX_RESPONSE_ARGS][MAX_RESPONSE_ARG_LEN];	// the args within the message
	
	if(debug) print("Parsing 01/0 message\n");

	//ensure the message isn't garbled
	if(!isValidMessage(message, 1, 0, 0, messageEnd, playerID, directConnect, debug)) return(OFF);
	
    //Initialize our parsing variables.
    messagePosition = 6; //End after the header.
    if(byte(message, messageEnd) != 2)	//if this doesn't end in a binary field delimiter
    {
	    messageEnd = MessageEnd - 3; //start after the checksum.
	}
    numArgs = 0;
	//Parse the necessary arguments.
	getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);
	
  	if(args[1] = "DEVICE_INFO") //what type of device are we talking to
  	{
  		connectedDeviceSN = args[3];
  		connectedDeviceID = atoi(args[4]);
		if(debug) print("Found DEVICE_INFO message.  args[3]=%s\n", args[3]);
		return(EVENT_01_DEVICE_INFO);
  	}
  	else if(args[1] = "DEVICE_POWER_STATE")
  	{
  		if(debug) print("Found DEVICE_POWER_STATE.  args[2]=%s\n", args[2]);
  		if(atoi(args[2]) > 0)
  			return(EVENT_01_POWER_STATE_ON);
  		else
  			return(EVENT_01_POWER_STATE_OFF);  			
  	}
  	
  	return(EVENT_VALID_MESSAGE);
}



#DEFINE_CONSTANT XY_TIMEOUT 40	//in tenths of a second.  
/* 
 * If the XY coordinates fail with an error saying "timeout", 
 * fix the Crestron bus or increase this number
 */

#DEFINE_CONSTANT SEQUENCE_ID 1
#DEFINE_CONSTANT CONTENT_DETAIL_LENGTH 250
#DEFINE_CONSTANT ZONE_ID_LENGTH 15
                                       
/*
 * In some cases, the Kaleidescape server is separated from
 * the control system by a router using NAT.  In these cases,
 * the private IP address of the server is not the IP Address
 * the Crestron panels must use to obtain cover art.
 *
 * In this case, an alternative address must be used to
 * access cover art.  Enter that address here.  This can be
 * a host name or an IP Address.
 *
 * NOTE: If your Crestron system and Kaleidescape server are
 * on the same subnet without any NAT between them,
 * DO NOT UNCOMMENT THE FOLLOWING CONSTANT DECLARATION.
 */                                       
//#DEFINE_CONSTANT SERVER_IP_ADDRESS "192.168.1.150"

#HELP_BEGIN
(c) 2004-2009 Kaleidescape Inc.  Please see legal notice below.

Version 7.0.1
Dated Jan 19, 2009

This module has been created and supported by Kaleidescape Inc.
This module is supported directly by Kaleidescape Inc.  Please
direct all inquiries regarding this module to  Kaleidescape support
at (650) 625-6160.  Crestron Inc. does not support this module itself.

This processor is for use within the Kaleidescape OSD Module

Inputs:
Player_ID	Indicates the player this module should communicate with.

Direct_Connect	Indicates if the player is directly connected (1) or 
			player is being routed through another player (0).

Rx$			String input received from the player.

Command_To_Player	Sends an arbritrary command to the player.

Outputs:
Tx$			String output sent to the player.

All other signal names are derived from the manual

----------------------------------------------------------------------
Debug mode can be activated by opening up the console and typing:
> userprogcmd "K debug"

It can subsequently be deactivated by typing:
> userprogcmd "K debug off"
----------------------------------------------------------------------

LEGAL NOTICE
    (c) 2004-2009 Kaleidescape Inc. This Source Code is the intellectual 
property of Kaleidescape, Inc. Kaleidescape grants the non-exclusive 
right to modify and/or compile and/or compress the Source Code, and 
upload such modified and/or compiled and/or compressed Source Code 
to control systems that control at least one licensed Kaleidescape 
System. No right is granted to otherwise copy, reproduce, modify, 
upload, download, transmit, or distribute the Source Code, or 
derivative works, in any way. The Source Code, and derivative works, 
are protected by copyright, trade secret, and other intellectual 
property laws and by international treaties, which provide rights 
and obligations in addition to the rights and obligations set forth here.

#HELP_END

/*******************************************************************************************
 * Input/Output Signal Declarations
 ******************************************************************************************/

DIGITAL_INPUT 	Touch_Channel;
DIGITAL_INPUT 	Using_Masking;
DIGITAL_INPUT 	Connection_Open;
DIGITAL_INPUT   Power_Off_Trigger;
DIGITAL_INPUT	Power_On_Trigger;
ANALOG_INPUT 	Stated_Player_ID;
ANALOG_INPUT 	Touch_X;
ANALOG_INPUT 	Touch_Y;

BUFFER_INPUT 	Rx$[INPUT_BUFFER_LENGTH];
STRING_INPUT 	Command_To_Player$[MAX_MESSAGE_LENGTH];
STRING_INPUT 	Keyboard_Input$[MAX_MESSAGE_LENGTH];

STRING_INPUT 	Play_Script$[MAX_MESSAGE_LENGTH];
STRING_INPUT 	Console_Command$[MAX_MESSAGE_LENGTH];
STRING_INPUT	Control_Music_Zone$[15];

DIGITAL_OUTPUT 	OSD_Saver;
DIGITAL_OUTPUT 	Camera_Angles_Available;
DIGITAL_OUTPUT 	Movies_Available;
DIGITAL_OUTPUT 	Music_Available;
DIGITAL_OUTPUT 	Details_Visible;

DIGITAL_OUTPUT 	Music_Playback_Active;

DIGITAL_OUTPUT	Random_Status;
DIGITAL_OUTPUT	Repeat_Status;

DIGITAL_OUTPUT  Power_On_fb;
DIGITAL_OUTPUT  Power_Off_fb;

STRING_OUTPUT 	Tx$;

ANALOG_OUTPUT 	Play_Mode;
ANALOG_OUTPUT 	Title_Length;
ANALOG_OUTPUT 	Title_Location;
ANALOG_OUTPUT 	Title_Remaining;
ANALOG_OUTPUT 	Title_Level;
ANALOG_OUTPUT 	Chapter_Number;
ANALOG_OUTPUT 	Chapter_Length;
ANALOG_OUTPUT 	Chapter_Location;
ANALOG_OUTPUT 	Chapter_Remaining;
ANALOG_OUTPUT 	Chapter_Level;

ANALOG_OUTPUT 	Movie_Location;

STRING_OUTPUT 	Now_Playing_Title_Name$;
STRING_OUTPUT 	Now_Playing_Artist_Name$;
STRING_OUTPUT 	Now_Playing_Album_Name_or_Chapter$;
STRING_OUTPUT	Now_Playing_Cover_Art_URL$;

ANALOG_OUTPUT 	OSD_Screen;
ANALOG_OUTPUT 	OSD_Popup;
ANALOG_OUTPUT 	OSD_Dialog;

ANALOG_OUTPUT 	Image_Aspect_Ratio;
ANALOG_OUTPUT 	Frame_Aspect_Ratio;

ANALOG_OUTPUT 	Mask_Data;
ANALOG_OUTPUT 	Mask_Conservative;

ANALOG_OUTPUT 	Protocol_Version;

ANALOG_OUTPUT 	User_Input;
STRING_OUTPUT 	User_Input_Prompt$;
STRING_OUTPUT 	User_Input_Text$;

ANALOG_OUTPUT 	Mask_Abs_Top;
ANALOG_OUTPUT 	Mask_Abs_Bottom;

ANALOG_OUTPUT  	Current_Camera_Angle;
ANALOG_OUTPUT  	Num_Camera_Angles;

ANALOG_OUTPUT 	Video_Mode_Composite;
ANALOG_OUTPUT 	Video_Mode_Component;
ANALOG_OUTPUT 	Video_Mode_HDMI;

STRING_OUTPUT 	User_Defined_Event$;

STRING_OUTPUT 	Friendly_Name$;
STRING_OUTPUT 	Details_Text$;
STRING_OUTPUT 	Details_Title$;
STRING_OUTPUT 	Details_Cover_URL$;

ANALOG_OUTPUT 	Mask_calibrated_top;
ANALOG_OUTPUT 	Mask_calibrated_bottom;

STRING_OUTPUT	Controlled_Music_SN_Zone$;
STRING_OUTPUT	Controlled_Music_CPDID_Zone$;

/*******************************************************************************************
 * Structure Definitions
 ******************************************************************************************/
 
/*
 * Note:  Be sure to initialize all declared STRING variables as needed
 *        For example, in Function Main: struct.myString = "";
 */
STRUCTURE 	STRUCT_Details
{ 
	//General purpose
	STRING 	library[CONTENT_DETAIL_LENGTH]; //Indicates whether this is for albums or music.
	STRING 	title[CONTENT_DETAIL_LENGTH];
	STRING 	albumTitle[CONTENT_DETAIL_LENGTH];
	STRING 	performer[CONTENT_DETAIL_LENGTH];
	STRING 	composer[CONTENT_DETAIL_LENGTH];
	STRING 	genre[CONTENT_DETAIL_LENGTH];
	STRING 	year[CONTENT_DETAIL_LENGTH];
	STRING 	coverURL[CONTENT_DETAIL_LENGTH];
	STRING 	runningTime[CONTENT_DETAIL_LENGTH];
	//STRING	contentHandle[CONTENT_DETAIL_LENGTH]; //Not used
	
	//Movies only
	STRING 	rating[CONTENT_DETAIL_LENGTH];
	STRING 	ratingReason[CONTENT_DETAIL_LENGTH];
	STRING 	synopsis[CONTENT_DETAIL_LENGTH];
	//STRING	colorDescription[CONTENT_DETAIL_LENGTH]; //Not used
	//STRING 	country[CONTENT_DETAIL_LENGTH];  //Not used
	//STRING	aspectRatio[CONTENT_DETAIL_LENGTH]; //Not used
	
	//Music only
	STRING	albumContentHandle[CONTENT_DETAIL_LENGTH];
	//STRING	lastPlayed[CONTENT_DETAIL_LENGTH]; //Not used
	//STRING	lastPlayedRelative[CONTENT_DETAIL_LENGTH]; //Not used
	//STRING	timesPlayed[CONTENT_DETAIL_LENGTH]; //Not used
	//STRING	trackNumber[CONTENT_DETAIL_LENGTH]; //Not used
	//STRING	review[CONTENT_DETAIL_LENGTH]; //Not used
	
	INTEGER numDetailsExpected;
};

/*******************************************************************************************
 * Global Variables
 ******************************************************************************************/
INTEGER 		_TouchXChanged;
INTEGER 		_TouchYChanged;
INTEGER 		_TouchPressed;
INTEGER 		_DirectConnect;
INTEGER			_SendTimeout;

INTEGER			_PowerState;
INTEGER			_PowerStateStatus;
STRING 			_ModuleDescription[100];
STRING 			_PlayerSN[16];
STRING			_DeviceName[50];
STRING 			_ConnectedDeviceSN[16];
INTEGER 		_PlayerId;
INTEGER 		_ConnectedDeviceID;
INTEGER			_NumVidZones;
INTEGER			_NumAudZones;
INTEGER 		_LastChapter;
STRING 			_MovieTitle[100];

INTEGER			_NumberOfDetails;
INTEGER			_NowPlayingDetailsLoading;
INTEGER			_NowPlayingDetailsPending;
STRING			_NowPlayingHandle[MAX_RESPONSE_ARG_LEN];
INTEGER			_BrowseDetailsLoading;
INTEGER			_BrowseDetailsPending;
STRING			_BrowseDetailsHandle[MAX_RESPONSE_ARG_LEN];
                    
STRUCT_Details 	_ContentDetail;

INTEGER 		_Debug;
INTEGER			_BinaryDelimiters;
INTEGER 		_ParsingFlag;
INTEGER			_FoundDelimiter;
INTEGER			_ConnectionState;

STRING			_ConnectionCommand[MAX_CONNECTION_COMMANDS][255];
INTEGER			_ConnectionCommandCount;

STRING			_MusicControlSN$[ZONE_ID_LENGTH];
STRING			_MusicControlCPDID$[2];
STRING			_MusicControlZone$[2];

/*******************************************************************************************
 * Functions
 ******************************************************************************************/
FUNCTION send(STRING data)
{
	STRING dataOut[MAX_MESSAGE_LENGTH];

	if(_PlayerId = 0)
	{
		if(Stated_Player_ID = 0)
		{
			print("Kaleidescape Player_Id not yet determined, not sending message: %s\n", data);
			return;
		}
		_PlayerId = Stated_Player_Id;
		if(_Debug) print("\"send\" setting Player_Id to Stated_Player_Id (%u).\n", _PlayerId);
	}
	
	makeString(dataOut,"%02d/%d/%s\n", _PlayerId, SEQUENCE_ID, data);
	
	if(_Debug) print("Sending:  %s", dataOut);
	
	Tx$ = dataOut;
	
	wait(500, sendTimeoutWait)
	{
		_sendTimeout = ON;
	}
}  

FUNCTION requestStartupStatus()
{
	STRING command[MAX_MESSAGE_LENGTH];
	
	delay(100);		//pause to clear any pending responses
	
	//Retreive current status
	send("GET_MOVIE_LOCATION:");
	send("GET_PLAY_STATUS:");
	send("GET_MUSIC_PLAY_STATUS:");
	send("GET_PLAYING_TITLE_NAME:");
	send("GET_UI_STATE:");
	send("GET_VIDEO_MODE:");
	send("GET_FRIENDLY_NAME:");
	send("GET_HIGHLIGHTED_SELECTION:");
	send("GET_CONTROLLED_ZONE:");
		
	if(Using_Masking = 1)
	{
		send("SET_SCREEN_MASK:1:");
	}
	
	send("GET_PROTOCOL:");

}


//clear out our info on the connected device (called when the connection drops)
FUNCTION clearStatus()
{
	if(_Debug) print("clearing status.\n");
	
	_PlayerId = Stated_Player_ID; //assume that the stated player ID is correct
	
	if(_PlayerId = 1)
		_DirectConnect = ON; //assume state of directly connected based on the player ID
	else
		_DirectConnect = OFF;

	_NumVidZones = 0;
	_NumAudZones = 0;
	_PlayerSN = "";
	_DeviceName = "";	
	
	Play_Mode = 999;
}

FUNCTION initConnection()
{
	refactorConnectionSettings(Stated_Player_ID, _PlayerSN, _PlayerID, _ConnectedDeviceSN, _ConnectedDeviceID, _DirectConnect, _Debug);

    _BinaryDelimiters = ON;	//attempt to turn on binary delimiters
    Tx$ = "01/0/SET_PROTOCOL_SETTINGS:BINARY_DELIMITERS:LATIN-1:\n";

    delay(100);	//pause to get a clear response
	
	send("GET_PROTOCOL:");

	if(_DirectConnect = OFF && _PlayerId != 1) //if we're not local
	{
		Tx$ = "01/0/ENABLE_EVENTS:" + itoa(_PlayerId) + ":\n";	//enable events for the device
		delay(100); //delay one second to ensure it's processed
	}
	
}

Function clearFeedback()
{
 	User_Input = 0;

 	OSD_Screen = 0;
 	OSD_Popup = 0;
 	OSD_Dialog = 0;
	Details_Visible = 0;

	Music_Playback_Active = 0;
	Play_Mode = 999;
	
	//set the controlled zone back to our home zone
	_MusicControlSN$ = right(_PlayerSN,12);
	makestring(_MusicControlCPDID$, "%02d", Stated_Player_ID);
	_MusicControlZone$ = "";
	Controlled_Music_SN_Zone$ = _MusicControlSN$ + "." + _MusicControlZone$;
	Controlled_Music_CPDID_Zone$ = _MusicControlCPDID$ + "." + _MusicControlZone$;
}

Function ConnectionEvent(INTEGER stateEvent)
{
	integer command, loop;
	command = ConnectionHandler(stateEvent, _ConnectionState, _ConnectionCommand, _ConnectionCommandCount, _PowerState, _PowerStateStatus, _ModuleDescription, _DirectConnect, _Debug);
	if(_Debug) print("ConnectionHandler said do %d.  PowerState = %d.\n", command, _PowerState);
	switch(command)
	{
		case(RESPONSE_NO_ACTION): 	 	return;	
		case(RESPONSE_SEND_COMMAND): 	{}		//no additional action
		case(RESPONSE_DIRECT_SEND):	 	Tx$ = _ConnectionCommand[MAX_CONNECTION_COMMANDS];
		case(RESPONSE_INITIALIZE): 	 	requestStartupStatus();
		case(RESPONSE_CLEAR_INIT):	 	clearStatus();
		case(RESPONSE_INIT_CONN):		initConnection();
		case(RESPONSE_POWERED_OFF):		clearFeedback();
	}
	
		//for every command we're to send, 
	for(loop = 1 to _ConnectionCommandCount)
	{
		Send(_ConnectionCommand[loop]);	//send it
	}
	_ConnectionCommandCount = 0;	//clear this
	
	Power_On_fb  = (_PowerState = POWER_ON);
	Power_Off_fb = (_PowerState = POWER_OFF);
}  



FUNCTION processAlienDeviceInfo(STRING message)
{
	INTEGER startpos;
	STRING SN[12];
	STRING CPDID[2];
	STRING command[MAX_MESSAGE_LENGTH];	
	
	if(mid(message,10,11) = "DEVICE_INFO")				//find the message if using CPDID
		startpos = 29;
	else if(mid(message,21,11) = "DEVICE_INFO")			//find the message if using SN
		startpos = 40;
	else return;
	
	SN = mid(message, startpos, 12);					//extract the serial number (12 digits)
	CPDID = mid(message, startpos+13, 2);				//extract the CPDID (field past SN)
	
	if(CPDID = _MusicControlCPDID$ && _MusicControlSN$ = "")	//if we've got a controlled CPDID, but no SN
	{
		_MusicControlSN$ = SN;									//store the SN
		command = "SET_CONTROLLED_ZONE:#" + _MusicControlSN$ + "." + _MusicControlZone$ + ":";	
		send(command);											//send the command to control the zone
	}
	else if(SN = _MusicControlSN$ && _MusicControlCPDID$ = "")	//if we've got an SN, but no CPDID
	{
		_MusicControlCPDID$ = CPDID;							//we've already sent the command to control the zone, just record the CPDID
		Controlled_Music_CPDID_Zone$ = _MusicControlCPDID$ + "." + _MusicControlZone$;		//and indicate the control
	}
	
}

FUNCTION setControlledZone()
{
	STRING command[MAX_MESSAGE_LENGTH];
	//	makestring(_MusicControlCPDID$, "%02s", target);	//ensure it's exactly two characters
	
	if(_MusicControlSN$ = "")
	{
		if(_MusicControlCPDID$ = "")				//if no CPDID was given either
			return;											//just return - nothing to do
			
		Tx$ = _MusicControlCPDID$ + "/0/GET_DEVICE_INFO:\n";	//ask for data about this CPDID
		return;												//can't do anything else until we get the SN		
	}
	
	//set the controlled zone
	command = "SET_CONTROLLED_ZONE:#" + _MusicControlSN$ + "." + _MusicControlZone$ + ":";
	send(command);
}

FUNCTION doRequestBrowseDetails()
{
	STRING command[MAX_MESSAGE_LENGTH];

	/*
	 * Next, we check to see how many threads are waiting to get content detail.  If there's
 	 * already one out there, we sit tight and wait for it to finish before we attempt to do our
	 * request
	 */
	if(_BrowseDetailsPending = ON) return; //if there is already a pending request, do nothing
	_BrowseDetailsPending = ON; //set the flag to prevent re-entering this routine
	
	//if we are already receiving content details...
	while(_BrowseDetailsLoading || _NowPlayingDetailsLoading)
	{
		delay(10); //check again in a moment
		
		wait(500, BROWSE_DETAILS_TIMEOUT) //failsafe - if 5 secs passes and still waiting
		{
			//assume the last command failed, and run anyway
			_BrowseDetailsLoading = OFF;
		}
	}
	cancelWait(BROWSE_DETAILS_TIMEOUT);	
	Details_Visible = OFF; //hide the window
	_BrowseDetailsPending = OFF; //clear the pending flag to allow re-entry
	_BrowseDetailsLoading = ON; //indicate that we are now going to run the command
	//Clear the pending flag for the proper detail and grab the handle to request.
	
	command = "GET_CONTENT_DETAILS:" + _BrowseDetailsHandle + "::";	
	send(command);
}

FUNCTION requestBrowseDetails(STRING handle)
{
	_BrowseDetailsHandle = handle;
	Details_Visible = OFF; //hide the window		
	wait(40)
	{
		doRequestBrowseDetails();
	}
}

FUNCTION doRequestNowPlayingDetails()
{
	STRING command[MAX_MESSAGE_LENGTH];
	/*
	 * Next, we check to see how many threads are waiting to get content detail.  If there's
 	 * already one out there, we sit tight and wait for it to finish before we attempt to do our
	 * request
	 */
	if(_NowPlayingDetailsPending = ON) return; //if there is already a pending request, do nothing
	_NowPlayingDetailsPending = ON; //set the flag to prevent re-entering this routine
	
	//if we are already receiving content details...
	while(_BrowseDetailsLoading || _NowPlayingDetailsLoading)
	{
		delay(10); //check again in a moment
		
		wait(500, NOW_PLAYING_DETAILS_TIMEOUT) //failsafe - if 5 secs passes and still waiting
		{
			//assume the last command failed, and run anyway
			_NowPlayingDetailsLoading = OFF;
		}
	}
	cancelWait(NOW_PLAYING_DETAILS_TIMEOUT);
	_NowPlayingDetailsPending = OFF; //clear the pending flag to allow re-entry
	_NowPlayingDetailsLoading = ON; //indicate that we are now going to run the command
	//Clear the pending flag for the proper detail and grab the handle to request.

	command = "GET_CONTENT_DETAILS:" + _NowPlayingHandle + "::";	
	send(command);
}

FUNCTION requestNowPlayingDetails(STRING handle)
{
	_NowPlayingHandle = handle;
	wait(40)
	{
		doRequestNowPlayingDetails();
	}
}


FUNCTION renderDetails()
{
	INTEGER totalSeconds;
	INTEGER totalMinutes;
	INTEGER hours;
	INTEGER minutes;
	STRING 	timeString[255];
	
	if("" != _ContentDetail.coverURL)
	{
		Details_Cover_URL$ = _ContentDetail.coverURL;
	}
	else
	{
		Details_Cover_URL$ = "";
	}

	if( "albums" = _ContentDetail.library) //Proper check order breaks Crestron compiler
	{
		totalSeconds = atoi(_ContentDetail.runningTime);
		hours = totalSeconds / 3600;
		minutes = (totalSeconds mod 3600) / 60;
		timeString = makeTimeString(hours, minutes);

		Details_Title$ = upper(_ContentDetail.performer) + " - " + upper(_ContentDetail.title);
		
		if(_ContentDetail.year = "")
		{
			Details_Text$ = timeString;
		}
		else
		{
			makeString(Details_Text$, "Released %s, %s", _ContentDetail.year, timeString);
		}
		
		//the APPEND_TEXT_2 is used here to fix a problem exhibited on the TPS-6000
		if("" != _ContentDetail.genre)
		{
			//substitute commas for line feeds
			_ContentDetail.genre = substitute(_ContentDetail.genre, CR, ", ");
			
			//if there's only one
   			if(find(",", _ContentDetail.genre) = 0)
   			{
				makeString(Details_Text$, "%s \r \rGENRE\r%s", APPEND_TEXT_2, _ContentDetail.genre);
	        }
	        else //more than one
	        {
		        makeString(Details_Text$, "%s \r \rGENRES\r%s", APPEND_TEXT_2, _ContentDetail.genre);
	        }
		}
			
		if("" != _ContentDetail.performer)
		{
			makeString(Details_Text$, "%s \r \rPERFORMER\r%s", APPEND_TEXT_2, _ContentDetail.performer);
		}
	}
	
	else if("movies" = _ContentDetail.library)
	{
		/*
		 * the following lines should be removed when the Running_time for movies is 
		 * corrected  *****
		 */
		totalMinutes = atoi(_ContentDetail.runningTime);
		hours = totalMinutes / 60;
		minutes = totalMinutes mod 60;
		timeString = makeTimeString(hours, minutes);
		
		//if there's both a time and year
		if(timeString != "" && "" != _ContentDetail.year)
		{
			timeString = timeString + ", ";
		}

        Details_Title$ = upper(_ContentDetail.title);
        
        makeString(Details_Text$, "Rated %s", _ContentDetail.rating);
        if("" != _ContentDetail.ratingReason)
        {
        	makeString(Details_Text$, "%s for %s", APPEND_TEXT_2, _ContentDetail.ratingReason);
        }
        
        if(timeString != "" || _ContentDetail.year != "")	//if there's a time or year
        {
        	makeString(Details_Text$, "%s; %s%s", APPEND_TEXT_2, timeString, _ContentDetail.year);
        }
        
        if("" != _ContentDetail.synopsis)
        {
        	makeString(Details_Text$, "%s \r \rSYNOPSIS\r%s", APPEND_TEXT_2, _ContentDetail.synopsis);
        }
        
        if("" != _ContentDetail.genre)
        {
        	//substitute commas for line feeds
   			_ContentDetail.genre = substitute(_ContentDetail.genre, CR, ", "); 
   			if(find(",", _ContentDetail.genre) = 0) //if there's only one
   			{
	        	makeString(Details_Text$, "%s \r \rGENRE\r%s", APPEND_TEXT_2, _ContentDetail.genre);
	        }
	        else //more than one
	        {
	        	makeString(Details_Text$, "%s \r \rGENRES\r%s", APPEND_TEXT_2, _ContentDetail.genre);
	        }
	        
        }
        	
        if("" != _ContentDetail.performer)
        {
        	//substitute commas for line feeds        	
   			_ContentDetail.performer = substitute(_ContentDetail.performer, CR, ", "); 
	        makeString(Details_Text$, "%s \r \rCAST\r%s", APPEND_TEXT_2, _ContentDetail.performer);
	    }
	        
	    if("" != _ContentDetail.composer)
	    {
	    	//substitute commas for line feeds
   			_ContentDetail.composer = substitute(_ContentDetail.composer, CR, ", "); 
	        if(find(",", _ContentDetail.composer) = 0) //if there's only one
	        {
	        	makeString(Details_Text$, "%s \r \rDIRECTOR\r%s", APPEND_TEXT_2, _ContentDetail.composer);
	        }
	        else //more than one
	        {
	        	makeString(Details_Text$, "%s \r \rDIRECTORS\r%s", APPEND_TEXT_2, _ContentDetail.composer);
	        }
	    }
	}
	
	Details_Visible = ON; //show the window
}



/*
 *       Kaleidescape responses and events have this format:
 *    
 *           01/1/000:COMMAND:ARG1:ARG2:ARG3:/28 
 *           
 *       where:
 *       
 *           01 is the device ID 
 *           1 is the sequence number (the same one we sent it in the command)
 *           000 is the status (000 means "success", anything else is an error)
 *           COMMAND identifies the kind of data being sent to us
 *           ARGn are the arguments of the command
 *           28 is the checksum of the message (always two digits)   
 *           
 *       So we will parse the response from the beginning to the end.
 *       Since we may be dealing with a serial connection, we must assume
 *       that this buffer may have been corrupted in transit.  We must be
 *       very careful to check that the syntax of the response is valid.
 *       (This is not really necessary when using TCP/IP since the TCP 
 *       layer ensures this for us.)
 */
        
//Parse the string within "message" and process   
FUNCTION parseMessage(string message)
{
	INTEGER messagePosition;
	INTEGER messageEnd;
	INTEGER messageIsValid;
	INTEGER numArgs; // the number of args	
   	INTEGER contentDetailsFinished;
   	INTEGER newOSDScreen;
	STRING  args[MAX_RESPONSE_ARGS][MAX_RESPONSE_ARG_LEN]; // the args within the message
	STRING 	playerIdSearchString[5];
	INTEGER binaryDelimited;
	INTEGER eventTrigger;
	STRING  fieldDelimiter[1];
	
	INTEGER errorCode;
		
	messageEnd = len(message);
    if(byte(message, messageEnd) = 4)
    {
    	binaryDelimited = ON;
    	fieldDelimiter = "\x02";
    	
    	messageEnd = messageEnd - 1;
    }
    else
    {
    	binaryDelimited = OFF;
    	fieldDelimiter = ":";
    	
	    // Remove trailing carriage return and/or linefeed
	    while (messageEnd > 0 && (byte(message, messageEnd) = CR || 
	    					  byte(message, messageEnd) = LF) )
	    {
	        messageEnd = messageEnd - 1;
	    }
	}
	
	/*
	 * trap the PLAYER_RESTART even if the message isn't addressed to us, 
	 * and if it lacks the leading 000:
	 */
	if(  mid(message,6, 14) = "PLAYER_RESTART"  )
	{	     
		//resetInterface(); //indicate that the player isn't yet initialized
		ConnectionEvent(EVENT_PLAYER_RESTART);
		return;
	}
	
	if( left(message,9) = "01/!/020:" )
	{
		ConnectionEvent(EVENT_01_BANG_020);
	}
    
    //if the device isn't yet online, engage our parser for device 01/0
    if( _ConnectionState < STATE_DEVICE_ONLINE )
    {
		//if this is an info message about the attached device, call the special parser
		if( mid(message,1,2) = "01" && mid(message,4,1) = "0" && mid(message,6,3) = "000" )
		{
			eventTrigger = parse010MessageEvent(message, messageEnd, _PlayerID, _DirectConnect, _ConnectedDeviceSN, _ConnectedDeviceID, _Debug);
			if(eventTrigger)
				ConnectionEvent(eventTrigger);
			return;
		}    
    }
    
	if(!_DirectConnect) //only check if we're not directly connected
	{
		//check for the available devices change message
		if( mid(message, 10, 17) = "AVAILABLE_DEVICES" )
		{
			if(_Debug) print("Searching for my device in AVAILABLE_DEVICES\n");
			//set up the string to look for (":00:") and store it in playerIdSearchString
			makeString(playerIdSearchString,"%s%02d%s", fieldDelimiter, _PlayerId, fieldDelimiter);
						
			//search for the Player id within the message
			if(find(playerIdSearchString, message, 27) > 0)
			{
				ConnectionEvent(EVENT_DEVICE_ONLINE);
			}
			else //logic falls here if the player isn't online
			{
				ConnectionEvent(EVENT_DEVICE_OFFLINE);						
			}
			return; //if the available devices message was found, don't bother processing further
		}
	}
		
	//determine if the message is valid
	messageIsValid = isValidMessage(message, _PlayerId, 0, 
									SEQUENCE_ID, messageEnd, _PlayerID, 
									_DirectConnect, _Debug);	
    if (!messageIsValid) 
    {
    	processAlienDeviceInfo(message);		//check for any alien device info
    	return;
    }
            	
	if(_Debug) print("Received:  %s\n", message);
    
	//Start after the header and checksum
	messagePosition = 1;
	if(byte(message,3) = '.') //if there's a stream ID
	{
	    messagePosition = messagePosition + 8; //start after the header (w/stream ID)
    }
    else
    {
	    messagePosition = messagePosition + 5; //start after the header
    }    
    if(!binaryDelimited)
    {    
    	messageEnd = messageEnd - 3;	//skip over the checksum of a printable delimited message
    }
    
    //clear any pending timeout
    cancelWait(SendTimeoutWait);
    _SendTimeout = OFF;
    ConnectionEvent(EVENT_VALID_MESSAGE);
    
    //Initialize our parsing variables.
    numArgs = 0;

	getNArguments(args, numArgs, 2, message, messagePosition, messageEnd);
    
    if(!(args[0] = "000")) //if there is an error condition noted by the player
    {
    	errorCode = atoi(args[0]);
    	
    	ConnectionEvent(EVENT_ERROR_OFFSET + errorCode);
    	
    	//pass the error code to the error handler
    	printPlayerError(errorCode,args[1], _PlayerId);
    	return;
   	}						
    
    if(args[1] = "PLAY_STATUS")
    {
    	getNArguments(args, numArgs, 10, message, messagePosition, messageEnd);
    	Play_Mode        = atoi(args[2]);
    	Title_Length     = atoi(args[5]);
    	Title_Location   = atoi(args[6]);
    	Chapter_Number   = atoi(args[7]); 
    	Chapter_Length   = atoi(args[8]); 
    	Chapter_Location = atoi(args[9]);
    	
    	if(Title_Length <> 0) //prevent div by 0 errors
    	{
    		//calculate level of current title
	    	Title_Level = Title_Location * 65535 / Title_Length;
	    }
	    else
	    {
	    	Title_Level = 0;
	    }
	    	
	    if(Chapter_Length <> 0) //prevent div by 0 errors
	    {
	    	//calculate level of current chapter
	    	Chapter_Level = Chapter_Location * 65535 / Chapter_Length;
	    }
	    else
	    {
	    	Chapter_Level = 0;
	    }
    	
    	Title_Remaining = Title_Length - Title_Location; //calculate title time remaining
    	Chapter_Remaining = Chapter_Length - Chapter_Location; //calculate chapter time remaining
    	
    	if(_LastChapter <> Chapter_Number) //if we've got to a new chapter
    	{
    		if(Chapter_Number > 0)
    		{
	    		Now_Playing_Album_Name_or_Chapter$ = "Chapter " + itoa(Chapter_Number);
	    	}
	    	else
	    	{
	    		Now_Playing_Album_Name_or_Chapter$ = " ";
	    	}
	    		
	    	Now_Playing_Artist_Name$ = " ";
	    		
    		_LastChapter = Chapter_Number; //remember the state
    	}
   	}
    else if(args[1] = "MUSIC_NOW_PLAYING_STATUS")	
    {
    	getNArguments(args, numArgs, 6, message, messagePosition, messageEnd);
    	
    	Chapter_Number = atoi(args[3]) + 1; //zero ref
    	Repeat_Status = (args[4] = "1");
    	Random_Status = (args[5] = "1");

	}	                                  
    else if(args[1] = "MUSIC_PLAY_STATUS")
    {
    	getNArguments(args, numArgs, 6, message, messagePosition, messageEnd);
    	
    	Play_Mode		= atoi(args[2]);    	
    	Title_Length 	= atoi(args[4]);
    	Title_Location	= atoi(args[5]);
    	Title_Remaining = Title_Length - Title_Location;
    	
    	Music_Playback_Active = (args[2] <> "0"); //indicate that music is playing
    	
    	if(Title_Length <> 0)
    	{
    		//calculate level of current title
    		Title_Level = Title_Location * 65535 / Title_Length;
    	}
    	else
    	{
    		Title_Level = 0;
    	}
    }    	
    else if(args[1] = "SCREEN_MASK")
    {
    	getNArguments(args, numArgs, 8, message, messagePosition, messageEnd);

    	Mask_Data         = atoi(args[2]);
    	Mask_Conservative = atoi(args[5]);
    	Mask_Abs_Top      = atoi(args[6]);	//convert to analog percentage
    	Mask_Abs_Bottom   = atoi(args[7]);	//convert to analog percentage
   	}    	
   	else if(args[1] = "SCREEN_MASK2")
   	{
   		getNArguments(args, numArgs, 6, message, messagePosition, messageEnd);

   		Mask_calibrated_top 	= atoi(args[4]);
   		Mask_calibrated_bottom 	= atoi(args[5]);
   	}
    else if(args[1] = "TITLE_NAME")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    	
    	Now_Playing_Title_Name$ = args[2];
    	_MovieTitle = args[2];
   	}   	
   	else if(args[1] = "MUSIC_TITLE")
   	{
   		getNArguments(args, numArgs, 7, message, messagePosition, messageEnd);
   		
   		if(args[2] = "")
   		{
   			Now_Playing_Title_Name$ = _MovieTitle;
   		}
   		else
   		{
	   		Now_Playing_Title_Name$ = args[2];
	   	}
	   	Now_Playing_Artist_Name$ = nullToSpace(args[3]);
		Now_Playing_Album_Name_or_Chapter$ = nullToSpace(args[4]);
		
		//Handle Cover Art
		Now_Playing_Cover_Art_URL$ = "";

		//retrieve the current song data (For the Cover URL only at this time)
		if(args[6] != "") //Check to see if we have a content handle
		{
			requestNowPlayingDetails(args[6]);
		}

   	}    	
    else if(args[1] = "UI_STATE")
    {
    	getNArguments(args, numArgs, 6, message, messagePosition, messageEnd);
    	
    	newOSDScreen = atoi(args[2]);
    	
    	//Check to see if we just switched from movies to music or vice versa...
	    if(OSD_Screen < 8 && newOSDScreen >= 8  || //We are switching from movies to music.
	    	OSD_Screen > 8 && newOSDScreen <= 8 ) //We are switching from music to movies
	    {
 			Details_Visible = OFF; //hide the window
	    }
    	
    	OSD_Screen = newOSDScreen;
    	OSD_Popup  = atoi(args[3]);
    	OSD_Dialog = atoi(args[4]);
    	if(args[5] = "1")
    	{
	    	OSD_Saver = ON;
	    }
	    else
	    {
	    	OSD_Saver = OFF;
	    }
	    	    
	}
    else if(args[1] = "MOVIE_LOCATION")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    	
    	Movie_Location = atoi(args[2]);
   	}
    else if(args[1] = "ASPECT_RATIO")
    {
    	getNArguments(args, numArgs, 4, message, messagePosition, messageEnd);
    	
    	Image_Aspect_Ratio = atoi(args[2]);
    	Frame_Aspect_Ratio = atoi(args[3]);
   	}  
  	else if(args[1] = "DEVICE_INFO") //what type of device are we talking to (sanity check)
  	{
  		getNArguments(args, numArgs, 4, message, messagePosition, messageEnd);
  		_PlayerSN = args[3];
  		ConnectionEvent(EVENT_DEVICE_INFO);
  	}
  	else if(args[1] = "NUM_ZONES")	//sanity check - ensure we've got a device that supports OSD
  	{
 		getNArguments(args, numArgs, 4, message, messagePosition, messageEnd);
 		
 		_NumVidZones = atoi(args[2]);
 		_NumAudZones = atoi(args[3]); 
 		
 		if( validateDevice("OSD Module", Stated_Player_ID, _DeviceName, _numVidZones, _numAudZones, 0) )
 			ConnectionEvent(EVENT_VALIDATED_CONFIG);
  	}
  	else if(args[1] = "DEVICE_TYPE_NAME")
  	{
  		getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
  		_DeviceName = args[2];
  	}  	  	
	else if(args[1] = "DEVICE_POWER_STATE")
	{
  		getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
  		
  		//print("power state args[2]=%s.  atoi(args[2]=%d\n", args[2], atoi(args[2]));
  		
  		if(args[2] != "0")
  			ConnectionEvent(EVENT_POWER_STATE_ON);
  		else
  			ConnectionEvent(EVENT_POWER_STATE_OFF);
  		
	}
	else if(args[1] = "PROTOCOL")
	{
		getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
		
		Protocol_Version = atoi(args[2]); //indicate the protocol version number
		
		if(Protocol_Version < 5)
		{
			Movies_Available = ON;
			Music_Available = OFF;
		}
		else
		{
			/*
			 * this should query the capabilities of the system.  
			 * For now, we'll assume both movies and music are available
			 */
			Movies_Available = ON;
			Music_Available = ON;
		}
	}	
	else if(args[1] = "USER_INPUT")
	{
		getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);
		
		User_Input = atoi(args[2]); //1=keyboard, 2=keypad
		
		if(args[3] = "") //if this is an empty string
		{
			args[3] = " "; //make it acceptable for TPs
		}
		User_Input_Prompt$ = args[3]; //the current prompt
		
		if(args[4] = "") //if this is an empty string
		{
			args[4] = " "; //make it acceptable for TPs
		}
		User_Input_Text$ = args[4]; //text that the user has typed
	}	
	else if(args[1] = "CAMERA_ANGLE")
	{
		getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);
	
		Current_Camera_Angle = atoi(args[2]);
		Num_Camera_Angles = atoi(args[3]);
		
		if(args[4] = "0")
		{
			Camera_Angles_Available = OFF;
		}
		else
		{
			Camera_Angles_Available = ON;
		}
	}
    else if(args[1] = "VIDEO_MODE")
    {
        getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);
    	
    	Video_Mode_Composite = atoi(args[2]);
    	Video_Mode_Component = atoi(args[3]);
    	Video_Mode_HDMI = atoi(args[4]);
    }
    else if(args[1] = "USER_DEFINED_EVENT")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    
    	User_Defined_Event$ = args[2];
    	delay(1);
    	User_Defined_Event$ = "";
    }
    else if(args[1] = "FRIENDLY_NAME")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    	
    	Friendly_Name$ = args[2];
    }
    else if(args[1] = "CONTROLLED_ZONE")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    	
    	if(_MusicControlSN$ != mid(args[2],2,12))					//if this isn't the control we thought we were getting
    	{
    		_MusicControlCPDID$ = "";								//clear the stored (probably invalid) CPDID
    	}
    	
   		_MusicControlSN$ = mid(args[2], 2, 12);						//set the SN
   		_MusicControlZone$ = mid(args[2], 15,2);					//and the zone
    		
   		if(_MusicControlSN$ = right(_PlayerSN,12))					//if this is our own player
   		{
   			makestring(_MusicControlCPDID$, "%02d", Stated_Player_ID);	//us our stated CPDID		
   		}
   		
		Controlled_Music_SN_Zone$ = _MusicControlSN$ + "." + _MusicControlZone$;
		
   		if(_MusicControlCPDID$ = "")								//if we don't know the CPDID
   		{
   			Tx$ = "#" + _MusicControlSN$ + "/0/GET_DEVICE_INFO:\n";	//ask about the CPDID
   		}
   		else														//otherwise, set the feedback
   		{
   			Controlled_Music_CPDID_Zone$ = _MusicControlCPDID$ + "." + _MusicControlZone$;
   		}
   		
    }
    else if(args[1] = "HIGHLIGHTED_SELECTION")
    {
    	getNArguments(args, numArgs, 3, message, messagePosition, messageEnd);
    	
    	Details_Visible = OFF; //Turn off the details visible selection.
    	if(isSignalDefined(Details_Text$) 		|| //if the details signals aren't used
    	   isSignalDefined(Details_Title$) ||
    	   isSignalDefined(Details_Cover_URL$) 	)
    	{
    		if(args[2] != "")//if there's data in the second field
    		{
    			requestBrowseDetails(args[2]); //retrieve the content details
	    	}
	    }
    }
    else if(args[1] = "CONTENT_DETAILS_OVERVIEW")
    {
	    getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);
    	if(_BrowseDetailsLoading)
    	{    	
			Details_Text$ = " "; //clear the field for more data
			_ContentDetail.numDetailsExpected = atoi(args[2]);
			_ContentDetail.library = args[4];
		
			//Clear all remaining fields
			_ContentDetail.title = "";
			_ContentDetail.albumTitle = "";
			_ContentDetail.performer = "";
			_ContentDetail.composer = "";
			_ContentDetail.genre = "";
			_ContentDetail.year = "";
			_ContentDetail.coverURL = "";
			_ContentDetail.runningTime = "";
			_ContentDetail.rating = "";
			_ContentDetail.ratingReason = "";
			_ContentDetail.albumContentHandle = "";		
			_ContentDetail.synopsis = "";
			Details_Visible = OFF; //hide the window
		}
		else if(_NowPlayingDetailsLoading)
		{
			_NumberOfDetails = atoi(args[2]);
		}
	}
    else if(args[1] = "CONTENT_DETAILS") //if this is a detail
    {    	
    	getNArguments(args, numArgs, 5, message, messagePosition, messageEnd);

		if(_BrowseDetailsLoading)
		{
	    	if(args[3] = "Artist")
		    {
		    	_ContentDetail.performer = args[4];
		    }
		    else if(args[3] = "Artists")		
		    {
		    	_ContentDetail.performer = args[4];
		    }
		    else if(args[3] = "Performer")
		    {
		    	_ContentDetail.performer = args[4]; 
			}
		    else if(args[3] = "Performers")
		    {
		    	_ContentDetail.performer = args[4]; 
			}
		    else if(args[3] = "Composer")
		    {
		    	_ContentDetail.composer = args[4]; 
			}
		    else if(args[3] = "Composers")
		    {
		    	_ContentDetail.composer = args[4]; 
			}
		    else if(args[3] = "Genre")
		    {
		    	_ContentDetail.genre = args[4]; 
			}
		    else if(args[3] = "Genres")
		    {
		    	_ContentDetail.genre = args[4]; 
			}
		    else if(args[3] = "Album_title")
		    {
		    	_ContentDetail.albumTitle = args[4]; 
			}
		    else if(args[3] = "Title")
		    {
		    	_ContentDetail.title = args[4]; 
			}	
		   	else if(args[3] = "Track_title")
		   	{
		   		_ContentDetail.title = args[4];
		   	}
		    else if(args[3] = "Album_year")
		    {
		    	_ContentDetail.year = args[4]; 
			}
		    else if(args[3] = "Rating")
		    {
		    	_ContentDetail.rating = args[4];
			}
		    else if(args[3] = "Rating_reason")
		    {
		    	_ContentDetail.ratingReason = args[4];
			}
		    else if(args[3] = "Year")
		    {
		    	_ContentDetail.year = args[4];
		    	if(_ContentDetail.year = "0")
		    	{
		    		_ContentDetail.year = "";
		    	}
			}
		    else if(args[3] = "Actors")
		    {
		    	_ContentDetail.performer = args[4];
			}
		    else if(args[3] = "Directors")
		    {
		    	_ContentDetail.composer = args[4];
			}
		    else if(args[3] = "Running_time")
		    {
		    	_ContentDetail.runningTime = args[4];    	
			}
			else if(args[3] = "Synopsis")
			{
				_ContentDetail.synopsis = args[4];
			}
		    else if(args[3] = "Cover_URL")
		    {
		    	#IF_NOT_DEFINED SERVER_IP_ADDRESS
			    	_ContentDetail.coverURL = args[4];
			   	#ENDIF

				#IF_DEFINED SERVER_IP_ADDRESS
					_ContentDetail.coverURL = processNAT(args[4], SERVER_IP_ADDRESS);
				#ENDIF		   		
		    }
		   	else if(args[3] = "Album_content_handle")
		   	{		   		
			   	_ContentDetail.albumContentHandle = args[4];
		   	}
	   	    
		   	//if we've seen the last detail, render the details
		   	if(atoi(args[2]) = _ContentDetail.numDetailsExpected)
		   	{
		   		//Set the title to the album title if title is empty.
		   		if(_ContentDetail.title = "" && _ContentDetail.albumTitle != "")
				{
					_ContentDetail.title = _ContentDetail.albumTitle;
				}
				
				//Return that the content has been fully loaded.
		   		_BrowseDetailsLoading = OFF;
		  		renderDetails();
		   	}
	    }
	    else if(_NowPlayingDetailsLoading)
	    {
	    	if(args[3] = "Cover_URL")
	    	{	    
	    		if(args[4] != "")
				{
					#IF_NOT_DEFINED SERVER_IP_ADDRESS
						Now_Playing_Cover_Art_URL$ = args[4];
					#ENDIF
					
					#IF_DEFINED SERVER_IP_ADDRESS
						Now_Playing_Cover_Art_URL$ = processNAT(args[4], SERVER_IP_ADDRESS);
					#ENDIF
				}
				else
				{
					Now_Playing_Cover_Art_URL$ = "";
				}
			}
			
			if(atoi(args[2]) >= _NumberOfDetails)
			{
				_NowPlayingDetailsLoading = OFF;
			}
	    }
    }
}


FUNCTION processRx()
{
	STRING message[MAX_MESSAGE_LENGTH];	// temporary variable to hold individual message
	STRING delimiter[2];

    _FoundDelimiter = OFF;

   	if(_BinaryDelimiters)
   	{
		delimiter = "\x04";		//binary
	}
	else
	{
		delimiter = "\n";		//printable
	}
   
	while( find(delimiter,Rx$) ) // while there is a delimiter
	{
		_FoundDelimiter = ON;		//set the flag (prevents the wait from acting while we're parsing)
		processLogic();
		message = remove(delimiter, Rx$); // remove individual message
		
		parseMessage(message);	// parse that message
	}
	
	if(Rx$ != "")
	{
		_FoundDelimiter = OFF;	//clear the flag
		wait(200, RxTimeout)	//if no message is found with the current delimiter by this timeout
		{
			if(Rx$ != "" && !_FoundDelimiter)
			{
				if(_Debug)
					print("Kaleidescape SATP Trying other delimiter.  _BinaryDelimiters = %i, len(Rx$) = %i\n", _BinaryDelimiters, len(Rx$));
					
				_BinaryDelimiters = !_BinaryDelimiters;	//change delimiters
				processRx();		//try and parse again
			}
		}
		retimeWait(200, RxTimeout);		//if the wait was already running, re-assert the time    		
	}
	else
	{
		cancelwait(RxTimeout);		//if the buffer is empty, cancel the wait
	}
}

/*******************************************************************************************
 * Event Handlers
 ******************************************************************************************/
CHANGE Rx$ 
{
	//ensure only 1 thread at a time (not truly thread-safe, but close enough)    
    if(_ParsingFlag) TerminateEvent;
    _ParsingFlag = ON;
	processRx();
	_ParsingFlag = OFF;
}


CHANGE Command_To_Player$
{
	STRING command[MAX_MESSAGE_LENGTH];
	
	command = Command_To_Player$ + ":";	//can't pass the STRING_INPUT by reference
	send(command);
}
              
              
CHANGE Keyboard_Input$
{
	INTEGER key;
	STRING 	escapeString[1];
	STRING 	command[MAX_MESSAGE_LENGTH];
	
	while(len(Keyboard_Input$)) //step through all input on this serial line
	{
		key = getC(Keyboard_Input$); //pull out 1 char at a time
		escapeString = ""; //reset the escape string
		if((key = BACKSLASH) || //if the key needs to be escaped
		   (key = ':') ||
		   (key = '/') )
		{
			escapeString = chr(BACKSLASH); //set the escape string
		}
		
		//build the keyboard string
		makeString(command, "KEYBOARD_CHARACTER:%s%c:", escapeString, key);	
		send(command); //send the command
	}
}
    
/*
 * The general concept of the touch interface is that the player only needs to coordinates of the 
 * selected area.  Since the same touch panel will provide the three events (X, Y, and Press) 
 * in various orders arriving at various times, the following code turns these three events into 
 * a single POSITION_SELECT.
 *
 * We are given 3 events:  Touch_Channel press, Touch_X change and Touch_Y change.
 *
 * Touch_X maintains _TouchXChanged, sets it to > 0 if Touch_X data is fresh, and sets it to 0 if 
 * Touch_X data becomes old.
 *
 * Touch_Y maintains _TouchYChanged, sets it to >0 if Touch_Y data is fresh, and sets it to 0 if 
 * Touch_Y data becomes old.
 *
 * Touch_Channel waits for valid Touch_X and Touch_Y data (as reported by the Touch_?_Changed
 * variables) then sends the POSITION_SELECT command.
 *
 *
 * The Touch_X and Touch_Y change events maintain the global variables _TouchXChanged and 
 * _TouchYChanged.  These variables increment on each trigger of the event.  Each re-entrant
 * change event waits for 2/10 of a second and checks to see if their my_change value is 
 * equal to the global variable, and if it is, they expire the global variable by setting 
 * it to 0.  This allows the Touch_Channel press event to monitor the global variables to 
 * determine that fresh data is available in Touch_X and Touch_Y, and to wait if it isn't 
 *available.
 */
 
RELEASE Touch_Channel
{
	wait(100, _TouchPressCheck)	//wait 10 seconds after the release to clear the flag
	{
		_TouchPressed = OFF;
	}
}

PUSH Touch_Channel
{
	INTEGER timeout;
	STRING 	command[MAX_MESSAGE_LENGTH];
	
	if(_Debug)
	{
		print(" Received Push.  X_Change = %d, Y_Change = %d, X:%u, Y:%u\n", 
			_TouchXChanged, _TouchYChanged, Touch_X, Touch_Y);
	}
	
	cancelWait(_TouchPressCheck);
	_TouchPressed = ON;
	
	timeout = 0;
	delay(1);

	//if we don't have changed coords
	while( ( _TouchXChanged = 0 || _TouchYChanged = 0 ) && timeout < XY_TIMEOUT )
	{
		delay(1); //pause a split second to ensure we have good XY coords
		timeout = timeout + 1; //count up the timeout
	}
		
	if(_Debug)
	{		
		print("Sending Push.  X_Change = %d, Y_Change = %d, X:%u, Y:%u (timeout=%d)\n", 
			_TouchXChanged, _TouchYChanged, Touch_X, Touch_Y,timeout);
	}
	
	if(_TouchXChanged = 0)
	{
		print("Kaleidescape OSD Module Error.  Touch press timeout with no touch coordinate X.\n");
		print("Check the signal path from the video window to the module.\n");
	}
		
	if(_TouchYChanged = 0)
	{
		print("Kaleidescape OSD Module Error.  Touch press timeout with no touch coordinate Y.\n");
		print("Check the signal path from the video window to the module.\n");
	}
	
	makeString( command, "POSITION_SELECT:%u:%u:", Touch_X, Touch_Y ); //create the command
	send(command); //send the command
}
	
//set these flags when the level data changes
CHANGE Touch_X
{
	INTEGER myChange;
	
	if(_Debug) print(" Received X:%u\n",Touch_X);
	
	_TouchXChanged = _TouchXChanged + 1; //increment the flag
	if(_TouchXChanged > 65530) _TouchXChanged = 1; //if we close to rolling, set back to 1
	
	myChange = _TouchXChanged; //remember where we left it
	delay(XY_TIMEOUT); //pause for timeout
	if(myChange = _TouchXChanged) //if the last change was ours
	{
		_TouchXChanged = 0; //expire it!
		
		if(_Debug) print(" X expired.  my_change=%d\n", myChange);
			
		if(_TouchPressed = OFF)
		{
			print("Kaleidescape OSD Module Error.  Received X Change from video window, but did not receive the digital event.\nCheck the signal path from the video window to the module.\n");
		}
	}
}
	
CHANGE Touch_Y
{
	INTEGER myChange;
	
	if(_Debug) print(" Received Y:%u\n",Touch_Y);
	
	_TouchYChanged = _TouchYChanged + 1;//increment the flag
	if(_TouchYChanged > 65530) _TouchYChanged = 1; //if we close to rolling, set back to 1
	
	myChange = _TouchYChanged; //remember where we left it
	delay(XY_TIMEOUT); //pause for timeout
	if(myChange = _TouchYChanged) //if the last change was ours
	{
		_TouchYChanged = 0; //expire it!
		
		if(_Debug) print(" Y expired.  my_change=%d\n", myChange);
		if(_TouchPressed = OFF)
		{
			print("Kaleidescape OSD Module Error.  Received Y Change from video window, but did");
			print(" not receive the digital event.\nCheck the signal path from the video window");
			print(" to the module.\n");
		}
	}
}	
	
CHANGE Play_Script$
{
	STRING command[MAX_MESSAGE_LENGTH];
	
	if(Play_Script$ != "") //if the name is not null
	{
		command = Play_Script$;
		command = escape(command); //escape the script name
		command = "PLAY_SCRIPT:" + command + ":"; //build the command
		send(command); //send the built command
		Play_Script$ = ""; //blank the input to allow re-triggering the same name
	}
}	

CHANGE Console_Command$
{
	STRING command[MAX_MESSAGE_LENGTH];
	
	command = upper(Console_Command$);
	
	if( command="K HELP" || command = "K?" || command="K ?" )
	{
		print("\n\nAll commands must be prefixed with userprogcmd.\n");
		print("use \"K debug\" to start debugging and \"K stop debug\" to stop.\n");
		print("\"K debug <device id>\" will start debugging only on the module using that device ID.\n");
		print("use \"K ver\" to obtain the module version information.\n");
		print("use \"K id\" to obtain the module device ID.\n");
		print("use \"K stop\" to stop all playback.\n\n");
	}
		
	if( command="K DEBUG"	|| 
	    ( left(command, 8)= "K DEBUG " && atoi(right(command, 2)) = _PlayerId ) )
	{
		print("Enabling Kaleidescape module debugging output for device ID %d.\n", _PlayerId);
		print("%s\n", _ModuleDescription);
		_Debug = ON;
	}
		
	if( command="K STOP DEBUG" || command="K NO DEBUG" || command="K DEBUG STOP" ) 
	{		
		print("Disabling Kaleidescape module debugging output.\n");
		_Debug = OFF;
	}
		
	if( command="K VER" || command="K VERSION" )
	{
		print("%s - Device ID %d\n", _ModuleDescription, _PlayerId);
	}

	if( command="K ID" )
	{
		print("Device ID %d\n", _PlayerId);
	}
	
	if( command="K STOP" )
	{
		send("STOP:");
	}

}
	
PUSH Connection_Open
{
	ConnectionEvent(EVENT_PORT_OPEN);
}
	
RELEASE Connection_Open
{
	ConnectionEvent(EVENT_PORT_CLOSED);	
}


PUSH Power_On_Trigger
{
	ConnectionEvent(EVENT_POWER_ON_PUSH);
}
 
RELEASE Power_On_Trigger
{
	ConnectionEvent(EVENT_POWER_ON_RELEASE);
}

PUSH Power_Off_Trigger	//This is here to inform the S+ that we're asking for standby and to set the power state.
{
	ConnectionEvent(EVENT_POWER_OFF_PUSH);
}

CHANGE Control_Music_Zone$
{
	INTEGER dot;
	STRING target[30];
	STRING zone[5];
	
	dot = find(".", Control_Music_Zone$);
	if(dot)
	{
		target = mid(Control_Music_Zone$, 1, dot-1);
		zone = mid(Control_Music_Zone$, dot+1, 2);
		zone = "00" + zone;
		zone = right(zone,2);							//ensure it's exactly 2 characters padded with "0"
		
		if(zone = "00") zone = "01";
		_MusicControlZone$ = zone;
	}
	else	//falls here if we didn't find a zone seperator
	{
		target = Control_Music_Zone$;
		_MusicControlZone$ = "01";
	}
	
	
	if(target = "" || target = "01" || atoi(target) = Stated_Player_ID)		//if the zone requested was null or 01 or self
	{
		_MusicControlSN$ = right(_PlayerSN,12);
		makestring(_MusicControlCPDID$, "%02d", Stated_Player_ID);
	}
	else if(len(target) > 2)		//if this is a serial number
	{
		target = "0000000000" + target;
		_MusicControlSN$ = right(target, 12);			//ensure it's exactly 12 characters padded with "0"
		_MusicControlCPDID$ = "";						//we don't know the CPDID yet
	}
	else												//this is likely a CPDID
	{
		target = "0" + target;
		_MusicControlCPDID$ = right(target,2);			//ensure it's exactly two characters padded with "0"
		_MusicControlSN$ = "";							//we don't know the SN yet
	}
	
	setControlledZone();
}

/*******************************************************************************************
 * Main()
 ******************************************************************************************/
FUNCTION Main()
{
	INTEGER lastDate;
	INTEGER idleCount;
	STRING 	command[255];
	
	_ContentDetail.title = "";
	_ContentDetail.genre = "";
	
	_ModuleDescription = "Kaleidescape Player Crestron Module v7.0.1.  Jan 19, 2009 " 
			+ " Library version " + getLibraryVersion();	
			
	_Debug = OFF;			
	//_Debug = ON;
	
	_ParsingFlag = OFF;
	_TouchPressed = OFF;
	
	//Preset the parsing flags.
	_BrowseDetailsPending = OFF;
	_BrowseDetailsLoading = OFF;
	_NowPlayingDetailsPending = OFF;
	_NowPlayingDetailsLoading = OFF;
	
	
    waitForInitializationComplete();
    
    delay(500); //wait an additional few seconds for ALL logic to be done propogating
    
    print("%s - Device ID %d\n",_ModuleDescription, _PlayerId);
    
    ConnectionEvent(EVENT_MODULE_START);
    
    //wait an additional random amount of time to prevent all modules init'ing at once
    delay(random(0,300));
	
	if(Connection_Open)	//if connection is already open (event may not have triggered)
	{
		ConnectionEvent(EVENT_PORT_OPEN);
	}
	
	if(Power_On_Trigger)
	{
		ConnectionEvent(EVENT_POWER_ON_PUSH);
	}
	
	
	
	while(1)
	{
		delay(1000); //every 10 seconds
		ConnectionEvent(EVENT_10_SECONDS);
		
		if(_SendTimeout) 
		{
			ConnectionEvent(EVENT_SEND_TIMEOUT);
			_SendTimeout = OFF;
		}
		
		idleCount = idleCount + 1;
		if(idleCount >= 3)
		{
			idleCount = 0;
			ConnectionEvent(EVERY_30_SECONDS);
		}
		
		if( lastDate != GetDateNum() ) //check if the day has changed
		{
			lastDate = GetDateNum(); //store the last date
			ConnectionEvent(EVENT_MIDNIGHT);
		}			
		
	}
	
}


